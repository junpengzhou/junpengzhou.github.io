<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AlphaDog</title>
  
  <subtitle>Junpengzhou&#39;s Blog, Welcome!</subtitle>
  <link href="https://www.junpengzhou.top/atom.xml" rel="self"/>
  
  <link href="https://www.junpengzhou.top/"/>
  <updated>2024-12-24T03:46:13.000Z</updated>
  <id>https://www.junpengzhou.top/</id>
  
  <author>
    <name>Junpengzhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>四象限法则时间管理法（Eeisenhower Matrix）</title>
    <link href="https://www.junpengzhou.top/article/5177e26d.html"/>
    <id>https://www.junpengzhou.top/article/5177e26d.html</id>
    <published>2024-12-24T03:46:13.000Z</published>
    <updated>2024-12-24T03:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一四象限法则定义">一、四象限法则定义</h1><p>EisenhowerMatrix，艾森豪威尔法则/矩阵，又称四象限法则，是指处理事情应分清主次，确定优先级别，以此来决定事务处理的先后顺序。</p><p>这一法则是由传奇将领、美国第34任总统艾森豪威尔（Eisenhower）将军提出的，堪称提高工作效率的“神器”，把工作按照重要和紧急两个不同程度划分为四个“象限”，分别为重要且紧急、重要不紧急、紧急不重要、不重要不紧急。它的最主要的观点是要将精力和时间放在那些重要但不紧急的事情上，对于其他的事情，只要事先都做好准备，就可以做到未雨绸缪，防患于未然。</p><p>具体实施上，四象限法则将“优先级”进一步拆分成两个维度：重要性和紧急程度。将重要性作为Y轴，紧急程度作为X轴，从而形成四个象限，这四个象限的划分有利于我们对时间进行深刻的认识及有效的管理。<img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/image-20241224122857719.png" alt="image-20241224122857719"></p><p>四象限分析法的目的就是用来分析事情的紧急程度，进而对时间或资源进行合理的配置。那么，我们又该如何确定一件事情的重要性和紧急程度呢？</p><ul><li><strong>第一象限</strong></li></ul><p>这个象限包含的是一些紧急而重要的事情，这一类的事情具有时间的紧迫性和影响的重要性，无法回避也不能拖延，必须首先处理优先解决。它表现为重大项目的谈判，重要的会议工作等。</p><ul><li><strong>第二象限</strong></li></ul><p>这二象限不同于第一象限，这一象限的事件不具有时间上的紧迫性，但是，它具有重大的影响，对于个人或者企业的存在和发展以及周围环境的建立维护，都具有重大的意义。</p><ul><li><strong>第三象限</strong></li></ul><p>第三象限包含的事件是那些紧急但不重要的事情，这些事情很紧急但并不重要，因此这一象限的事件具有很大的欺骗性，它很紧急的事实造成了它很重要的假象，耗费了人们大量的时间。</p><ul><li><strong>第四象限</strong></li></ul><p>第四象限的事件大多是些琐碎的杂事，没有时间的紧迫性，没有任何的重要性，这种事件与时间的结合纯粹是在扼杀时间，是在浪费生命。</p><h1 id="二四象限工作规划表示例">二、四象限工作规划表示例</h1><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/timefourquadrantrule00.png" alt="img"></p><p>第一象限和第四象限是相对立的，而且是壁垒分明的，很容易区分。</p><p>第一象限是紧急而重要的事情，每一个人包括每一个企业都会分析判断那些紧急而重要的事情，并把它优先解决。</p><p>第四象限是既不紧急，又不重要的事情，有志向而且勤奋的人断然不会去做。</p><p>第二象限和第三象限最难以区分，第三象限对人们的欺骗性是最大的，它很紧急的事实造成了它很重要的假象，耗费了人们大量的时间。</p><p>依据紧急与否是很难区分这两个象限的，要区分它们就必须借助另一标准，看这件事是否重要。也就是<strong>按照自己的人生目标和人生规划来衡量这件事的重要性</strong>。如果它重要就属于第二象限的内容；如果它不重要，就属于第三象限的内容。</p><p>第一象限的事情重要而且紧急，由于时间原因人们往往不能做得很好。第二象限的事情很重要，而且会有充足的时间去准备，有充足的时间去做好。可见，投资第二象限，它的回报才是最大的。</p><p>走出毫无意义的第三象限，把有限的时间投入到最具收益的第二象限去，不要再在第三象限做那些紧急但是不重要的无聊事情了。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/image-20241224140750160.png" alt="image-20241224140750160"></p><p>上面是一个普通人和高效能人士时间安排的一个比较图。高效能人士的时间安排是，把65%-80%的时间安排在重要但不紧急的工作，由于他们把大部分工作都提前统筹和规划好了，其余象限的工作自然而然就减少了。</p><p>第二象限重要但不紧急的工作包括问题的发掘与预防、持续学习、关于团队的建设、真正有效的授权、确定自己的个人使命、长期的职业生涯规划、个人使命等。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/13120428-6c25250a98160c12.JPEG" alt="img"></p><h1 id="三处理四象限事务的法则">三、处理四象限事务的法则</h1><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/400px-%25E6%2597%25B6%25E9%2597%25B4%25E7%25AE%25A1%25E7%2590%2586.png" alt="img"></p><p>其实可以看出我们在优化清单时是按照先轻重再缓急的思路，所有我们在安排工作时应该把主要的精力放在重要的事项，首先重要且紧急的优先级肯定最高，对于重要不紧急或者紧急不重要的事情，我们应该把更多的精力放在重要不紧急的事项上。以我个人为例，同样一件事情，如果有时间截止日期的要求，处理起来的时候就会特别烦躁而且不能静下心来进行处理。</p><p><strong>1、第一象限：立即去做（立刻做）</strong></p><p>重要且紧急，立即去做，类似于孩子填报志愿、处理媒体对公司的负面报道等等，无可否认，肯定是第一优先级进行处理，否则后果非常严重，不过在立即去做的同时得思考真的有那么重要且紧急的事情吗。我们工作中的主要压力和生活的主要压力就是来自于第一象限的任务，但第一象限中80%的任务都是来自于第二象限中没有被很好处理的事务。</p><p>比如孩子填报志愿，如果把填报志愿前100天的时候，就是一项第二象限的工作，然后可以有计划的考虑，是否要了解孩子的兴趣，是否要听长辈的说法，是否要知道专业的发展情况，如果在填报志愿当天或者前两三天考虑，那就是第一象限的工作，然后你就会火急火燎的做出一个决定，很明显这个决定肯定不会比纳入第二象限时就开始处理来的周全。</p><p><strong>2、第二象限：投资象限，有计划的去做（计划做）</strong></p><p>重要但不紧急，有计划的去做。比如编写下个季度的工作计划、指定家庭投资理财策略。这些事情虽然看起来不紧急，但如果不处理的话随时都会发展成为重要而且紧急的事情。对于这类事情，也要制定一份时间计划表，持续推进，避免进入第一象限。作者在书中给出的方法如下：</p><p><strong>1）对第二象限的事务进行目标描述和任务分解</strong></p><p>如果是放在第二象限的事情，那基本上都可以称之为一个项目，需要对项目进行任务分解，然后给出项目及各个任务的目标，同时给出计划时间和负责人。这样做的好处：</p><p>当我们开始做的时候，就迫使我们将精力花在第二象限中，再小的一个动作也是一种开始；</p><p>有利于将一个项目做细，做的有计划，时刻知道下一步该做什么（这里面有个小提示，切忌进入无休止的计划时间）</p><p>明确任务完成的标准，当给任务设定标准时，就知道什么时候算达成任务；</p><p>分解后的小任务有利于进度控制，可以随时提醒自己截止日期，这也是避免进入第一象限的关键。</p><p><strong>3、第三象限：交给别人去做，用“猴子法则”走出第三象限（授权做）</strong></p><p>不重要但紧急，比如<strong>客户的求救电话，临时电话会议</strong>，这个部分的<strong>精力开销是不可避免</strong>的，但是不能认为紧急的就是重要的，需要评估这件事情相对于手头其他事情的重要程度再做决定。作者提出的“猴子法则”是我上次看完这本书的最大收获，可能第二象限的工作方法需要长期修炼，那猴子法则应该是比较容易入手的。</p><p><strong>大部分人发现时间不够的主要原因是将太多不属于自己的工作揽在自己身上</strong>。比如一个同事遇到一个麻烦，然后跑过来跟你抱怨，原本这个事情是在你同事身上，结果你开始关切的听他讲述，然后这个问题果然很麻烦，你没法直接给出答复，你就说“这个问题确实复杂，需要再仔细想想”，结果原本在你同事头上的猴子就跳到你身上，你同事就变成监督者，时不时都有可能会问你思考的怎么样。</p><p>虽然你可能会说你只是善心，但我们应该避免这种情况，让他们把你当做自己猴子的收容站，收的越多，他们给的就越多，最后你可以光顾着照顾别人的猴子，没有精力照顾自己的猴子。</p><p>上面主要是说不要做老好人，<strong>另一方面可以应用与在团队协作时不要让工作进度停留在自己身上</strong>。当你手上碰到的事情需要其他同事协助处理时，就需要在知道事情时尽早将事情转交给其他同事，你只是负责跟进进度，而不是一直将事项放在自己这边，等到最后时刻才想起转交给同事。这个习惯对我受益非常大，一方面给同事预留了充足的时间，另一方面基本上都是我去push别人而不是别人来push我，整个人的工作状态也会变好。</p><p>简单来说，就是甩掉自己身上的猴子，或者将猴子放回到他主人身上去。下面是书中给出的几个经典例子，如果看文字不好理解的话，可以结合下面的例子进行理解。</p><p><strong>案例：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">老板问：关于水利系统软件的那个项目，想和你谈一谈</span><br><span class="line">你回答：好的老板，不过能否请你先发给我一份关于水利系统软件的资料？</span><br><span class="line"></span><br><span class="line">下属问：我们怎么解决项目预算超支的问题？</span><br><span class="line">你回答：你有什么想法？能不能先请你做一个删减成本的计划案？</span><br><span class="line"></span><br><span class="line">同事问：我什么时候能拿到这个软件的操作说明书？</span><br><span class="line">你回答：我已经让××去做了，他会直接发给你。</span><br><span class="line"></span><br><span class="line">老婆问：明天下午能否和我一起逛街？</span><br><span class="line">你回答：老婆，下个月结婚纪念日的时候我陪你近一整天，好吗？</span><br><span class="line"></span><br><span class="line">朋友问：这周六咱们一起去打羽毛球吧？</span><br><span class="line">你回答：好啊，到时侯你给我打电话，有时间我一定去。</span><br><span class="line"></span><br><span class="line">父母问：家里的空调坏了，换一个新的吧？</span><br><span class="line">你回答，行啊，你们选好喜欢的品牌和款式，到时候我去买。</span><br></pre></td></tr></table></figure><p><strong>4、第四象限：尽量别去做（避免做）</strong></p><p>不重要而且不紧急，比如看<strong>无聊的电视节目</strong>、<strong>刷手机</strong>等。这个象限的事情用来当做前三个象限的调剂还差不多，<strong>可以通过做一些不重要且不紧急的事情来调整自己的心态和身体</strong>，但如果一直<strong>沉迷于第四象限</strong>，那我们的<strong>产出就会打折扣</strong>，就是在浪费生命。比如，当身心疲惫的时候，约上几个哥们一起吃饭喝酒，这叫劳逸结合，但如果每天都这么做，那就是不务正业了。</p><h1 id="四四象限法则小结">四、四象限法则小结</h1><p>对以上的内容我们来做个简单的总结，先把事项分类然后放入四象限中，然后针对不同象限中的事情各个击破，具体如下：</p><p>1、根据自己的职业价值观判断事项的重要程度；</p><p>2、根据事项的时间截止期限判断其紧急程度；</p><p>3、将待办清单中所有事项归类放到四象限中；</p><p>4、对四象限中的不同象限的事项采取不同的处理原则和方式；</p><p>5、应该将主要的时间精力放在解决第二象限的事项，避免其变成第一象限，我们所谓的工作计划和任务目标是针对第二象限的事项来说的；</p><p>6、应该采用猴子法则走出第三象限；</p><p>7、第四象限的事情适当调剂即可，切不可长期沉迷。</p><h1 id="参考文档">参考文档</h1><ol type="1"><li><a href="https://www.jianshu.com/p/30b2ab0dc20e">https://www.jianshu.com/p/30b2ab0dc20e</a></li><li><a href="https://www.jindumao.com/newcontent/id/23.html">https://www.jindumao.com/newcontent/id/23.html</a></li><li><a href="https://boardmix.cn/article/timefourquadrantrule/">https://boardmix.cn/article/timefourquadrantrule/</a></li><li><a href="https://asana.com/resources/eisenhower-matrix">https://asana.com/resources/eisenhower-matrix</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一四象限法则定义&quot;&gt;一、四象限法则定义&lt;/h1&gt;
&lt;p&gt;Eisenhower
Matrix，艾森豪威尔法则/矩阵，又称四象限法则，是指处理事情应分清主次，确定优先级别，以此来决定事务处理的先后顺序。&lt;/p&gt;
&lt;p&gt;这一法则是由传奇将领、美国第34任总统艾森豪威尔（</summary>
      
    
    
    
    <category term="日常分享" scheme="https://www.junpengzhou.top/categories/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="时间管理" scheme="https://www.junpengzhou.top/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>响应式编程与异步编程和多线程编程的关系</title>
    <link href="https://www.junpengzhou.top/article/d0ee7058.html"/>
    <id>https://www.junpengzhou.top/article/d0ee7058.html</id>
    <published>2024-12-17T08:25:38.000Z</published>
    <updated>2024-12-17T08:25:38.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Reactor实战之Mono与Flux</title>
    <link href="https://www.junpengzhou.top/article/34ed37b6.html"/>
    <id>https://www.junpengzhou.top/article/34ed37b6.html</id>
    <published>2024-12-17T07:33:24.000Z</published>
    <updated>2024-12-18T06:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>响应式编程用的是越来越多，尤其是在移动端Android的应用上边</p><p>在Java后台服务开发中， 响应式编程用的不是太广泛，主要原因是，响应式编程需要一个完整的生态，包括数据库、缓存、中间件，都需要配套的响应式组件，受到以上局限，因此响应式编程在服务端大规模运用的案例少之又少</p><p>但是随着 <code>Spring Cloud Gateway</code>的火爆，在业务路由网关中应用响应式编程可以帮助我们更好的管理微服务的路由和IO处理，因此响应式编程后端又变成了不可回避，不得不去学习的技术</p><p>官方文档：<a href="https://projectreactor.io/docs/core/release/reference/aboutDoc.html">https://projectreactor.io/docs/core/release/reference/aboutDoc.html</a></p><h2 id="响应式编程概述">响应式编程概述</h2><h3 id="背景知识">背景知识</h3><p>为了应对高并发服务器端开发场景，在2009年，微软提出了一个更优雅地实现异步编程的方式——ReactiveProgramming，我们称之为响应式编程。随后，Netflix 和LightBend公司提供了RxJava 和Akka Stream 等技术，使得Java平台也有了能够实现响应式编程的框架</p><p>在2017 年9 月28 日，Spring 5 正式发布。Spring 5发布最大的意义在于，它将响应式编程技术的普及向前推进了一大步。而同时，作为在背后支持Spring5 响应式编程的框架Spring Reactor，也进入了里程碑式的3.1.0 版本</p><h3 id="什么是响应式编程">什么是响应式编程</h3><p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播</p><p>响应式编程基于Reactor（Reactor 是一个运行在 Java8之上的响应式框架）的思想，当你做一个带有一定延迟的才能够返回的io操作时，不会阻塞，而是立刻返回一个流，并且订阅这个流，当这个流上产生了返回数据，可以立刻得到通知并调用回调函数处理数据</p><p>电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似"=B1+C1"的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化</p><p>Vue作为一种响应式编程框架，官方提到<code>Vue.js的响应式原理就是自动追踪数据的变化，从而实现数据驱动视图的更新</code></p><p>响应式传播核心特点之一：变化传播，一个单元格变化之后，会像多米诺骨牌一样，导致直接和间接引用它的其他单元格均发生相应变化</p><h3 id="基于java8实现观察者模式">基于Java8实现观察者模式</h3><p>Observable类：此类表示可观察对象，或模型视图范例中的“数据”</p><p>它可以被子类实现以表示应用程序想要观察的对象，也被称之为“被观察者”或者“主题”（Subject）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想要观察的对象 ObserverDemo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverDemo</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ObserverDemo</span> <span class="variable">observerDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverDemo</span>();</span><br><span class="line">        <span class="comment">// 添加观察者（Observer）</span></span><br><span class="line">        observerDemo.addObserver((o,arg)-&gt;{</span><br><span class="line">            System.out.println(<span class="string">"数据发生变化A"</span>);</span><br><span class="line">        });</span><br><span class="line">        observerDemo.addObserver((o,arg)-&gt;{</span><br><span class="line">            System.out.println(<span class="string">"数据发生变化B"</span>);</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// 将此Observable对象标记为已更改</span></span><br><span class="line">        observerDemo.setChanged();</span><br><span class="line">        <span class="comment">// 如果该对象发生了变化，则通知其所有观察者</span></span><br><span class="line">        observerDemo.notifyObservers();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>启动程序测试：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/e2c55c0a1df548f0af86c4e93f9b1ce3.png" alt="在这里插入图片描述"></p><h3 id="创建一个observable">创建一个Observable</h3><p><code>rxjava</code>(Netflix出品的一个响应式编程开发库)中，可以使用Observable.create()该方法接收一个Obsubscribe对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.create(<span class="keyword">new</span> <span class="title class_">Observable</span>.OnSubscribe&lt;Integer&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> Integer&gt; subscriber)</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></table></figure><p>来个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 完整写法</span></span><br><span class="line">        <span class="comment">// 创建被观察者</span></span><br><span class="line">        Observable&lt;String&gt; observable = Observable.create(emitter -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                emitter.onNext(i + <span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line">            emitter.onComplete();</span><br><span class="line"><span class="comment">//            throw new RuntimeException("抛出一个错误进行测试");</span></span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// 添加第一个观察者</span></span><br><span class="line">        observable.subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> {</span><br><span class="line">                log.info(<span class="string">"订阅事件1-观察者1-上线"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(<span class="meta">@NonNull</span> String string)</span> {</span><br><span class="line">                log.info(<span class="string">"订阅事件1-观察者1-收到的内容：{}"</span>, string);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> {</span><br><span class="line">                log.error(<span class="string">"订阅事件1-观察者1-错误"</span>, e);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> {</span><br><span class="line">                log.info(<span class="string">"订阅事件1-观察者1-结束"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加第二个观察者</span></span><br><span class="line">        observable.subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> {</span><br><span class="line">                log.info(<span class="string">"订阅事件1-观察者2-上线"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(<span class="meta">@NonNull</span> String string)</span> {</span><br><span class="line">                log.info(<span class="string">"订阅事件1-观察者2-收到的内容：{}"</span>, string);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> {</span><br><span class="line">                log.error(<span class="string">"订阅事件1-观察者2-错误"</span>, e);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> {</span><br><span class="line">                log.info(<span class="string">"订阅事件1-观察者2-结束"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">订阅事件1-观察者1-上线</span><br><span class="line">订阅事件1-观察者1-收到的内容：0</span><br><span class="line">订阅事件1-观察者1-收到的内容：1</span><br><span class="line">订阅事件1-观察者1-收到的内容：2</span><br><span class="line">订阅事件1-观察者1-收到的内容：3</span><br><span class="line">订阅事件1-观察者1-收到的内容：4</span><br><span class="line">订阅事件1-观察者1-结束</span><br><span class="line">订阅事件1-观察者2-上线</span><br><span class="line">订阅事件1-观察者2-收到的内容：0</span><br><span class="line">订阅事件1-观察者2-收到的内容：1</span><br><span class="line">订阅事件1-观察者2-收到的内容：2</span><br><span class="line">订阅事件1-观察者2-收到的内容：3</span><br><span class="line">订阅事件1-观察者2-收到的内容：4</span><br><span class="line">订阅事件1-观察者2-结束</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，在Observer订阅了Observable后，Observer被作为subscribe中方法的参数传入，从而调用了Observer的相关方法</p><h3 id="基于-reactor-实现">基于 Reactor 实现</h3><p>Reactor 是一个运行在 Java8 之上满足 Reactice规范的响应式框架，它提供了一组响应式风格的 API。</p><p>Reactor 有两个核心类： <code>Flux&lt;T&gt;</code> 和<code>Mono&lt;T&gt;</code>，这两个类都实现 Publisher 接口。</p><ul><li>Flux 类似 RxJava 的Observable，它可以触发零到多个事件，并根据实际情况结束处理或触发错误。</li><li>Mono类似RxJava的Maybe，最多只触发一个事件，常见的用法是用于在异步任务完成时发出通知。</li></ul><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/2e5d2af3e0c94a1478b3dcff3f45c2be.png" alt="preview"></p><p>Flux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono都可以发出三种数据信号：元素值，错误信号，完成信号；错误信号和完成信号都代表终止信号，终止信号用于告诉订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者。</p><p>三种信号的特点：</p><ul><li>错误信号和完成信号都是终止信号，不能共存</li><li>如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流</li><li>如果没有错误信号，也没有完成信号，表示是无限数据流</li></ul><blockquote><p>引入依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>just 和 subscribe方法</p></blockquote><p>just()：创建Flux序列，并声明指定数据流</p><p>subscribe()：订阅Flux序列，只有进行订阅后才回触发数据流，不订阅就什么都不会发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReactor</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// just()：创建Flux序列，并声明数据流，</span></span><br><span class="line">        Flux&lt;Integer&gt; integerFlux = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);<span class="comment">//整形</span></span><br><span class="line">        <span class="comment">//subscribe()：订阅Flux序列，只有进行订阅后才回触发数据流，不订阅就什么都不会发生</span></span><br><span class="line">        integerFlux.subscribe(System.out::println);</span><br><span class="line">        </span><br><span class="line">        Flux&lt;String&gt; stringFlux = Flux.just(<span class="string">"hello"</span>, <span class="string">"world"</span>);<span class="comment">//字符串</span></span><br><span class="line">        stringFlux.subscribe(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fromArray(),fromIterable()和fromStream()：可以从一个数组、Iterable 对象或Stream 对象中创建Flux序列</span></span><br><span class="line">        Integer[] array = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">        Flux.fromArray(array).subscribe(System.out::println);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(array);</span><br><span class="line">        Flux.fromIterable(integers).subscribe(System.out::println);</span><br><span class="line">        </span><br><span class="line">        Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">        Flux.fromStream(stream).subscribe(System.out::println);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>启动测试：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/adca59c8d9e04ce58d3b9570cbc1bed4.png" alt="在这里插入图片描述"></p><h2 id="响应流的特点">响应流的特点</h2><p>要搞清楚这两个概念，必须说一下响应流规范。它是响应式编程的基石。他具有以下特点：</p><ul><li>响应流必须是无阻塞的。</li><li>响应流必须是一个数据流。</li><li>它必须可以异步执行。</li><li>并且它也应该能够处理背压。</li><li><strong>即时响应性:</strong> 只要有可能， <a href="https://www.reactivemanifesto.org/zh-CN/glossary#System">系统</a>就会及时地做出响应。即时响应是可用性和实用性的基石，而更加重要的是，即时响应意味着可以快速地检测到问题并且有效地对其进行处理。即时响应的系统专注于提供快速而一致的响应时间， 确立可靠的反馈上限，以提供一致的服务质量。 这种一致的行为转而将简化错误处理、建立最终用户的信任并促使用户与系统作进一步的互动。</li><li>**回弹性：**系统在出现<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Failure">失败</a>时依然保持即时响应性。这不仅适用于高可用的、任务关键型系统——任何不具备回弹性的系统都将会在发生失败之后丢失即时响应性。回弹性是通过<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Replication">复制</a>、遏制、 <a href="https://www.reactivemanifesto.org/zh-CN/glossary#Isolation">隔离</a>以及<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Delegation">委托</a>来实现的。失败的扩散被遏制在了每个<a href="https://www.cnblogs.com/glossary.zh-cn.md#组件">组件</a>内部，与其他组件相互隔离，从而确保系统某部分的失败不会危及整个系统，并能独立恢复。每个组件的恢复都被委托给了另一个（外部的）组件，此外，在必要时可以通过复制来保证高可用性。（因此）组件的客户端不再承担组件失败的处理。</li><li><strong>弹性：</strong>系统在不断变化的工作负载之下依然保持即时响应性。反应式系统可以对输入（负载）的速率变化做出反应，比如通过增加或者减少被分配用于服务这些输入（负载）的<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Resource">资源</a>。这意味着设计上并没有争用点和中央瓶颈， 得以进行组件的分片或者复制，并在它们之间分布输入（负载）。 通过提供相关的实时性能指标，反应式系统能支持预测式以及反应式的伸缩算法。这些系统可以在常规的硬件以及软件平台上实现成本高效的<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Elasticity">弹性</a><a href="https://www.reactivemanifesto.org/zh-CN/glossary#Elasticity">。</a></li><li><a href="https://www.reactivemanifesto.org/zh-CN/glossary#Elasticity">**消息驱动：**反应式系统依赖</a><a href="https://www.reactivemanifesto.org/zh-CN/glossary#Asynchronous">异步的</a><a href="https://www.reactivemanifesto.org/zh-CN/glossary#Message-Driven">消息传递</a>，从而确保了松耦合、隔离、<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Location-Transparency">位置透明</a>的组件之间有着明确边界。这一边界还提供了将<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Failure">失败</a>作为消息委托出去的手段。使用显式的消息传递，可以通过在系统中塑造并监视消息流队列，并在必要时应用<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Back-Pressure">回压</a>，从而实现负载管理、 弹性以及流量控制。使用位置透明的消息传递作为通信的手段，使得跨集群或者在单个主机中使用相同的结构成分和语义来管理失败成为了可能。<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Non-Blocking">非阻塞的</a>通信使得接收者可以只在活动时才消耗<a href="https://www.reactivemanifesto.org/zh-CN/glossary#Resource">资源</a>，从而减少系统开销。</li></ul><h2 id="publisherflux和mono">Publisher/Flux和Mono</h2><p>由于响应流的特点，我们不能再返回一个简单的<strong>POJO</strong>对象来表示结果了。必须返回一个类似<strong>Java</strong>中的<code>Future</code>的概念，在有结果可用时通知消费者进行消费响应。</p><p><strong>Reactive Stream</strong>规范中这种被定义为Publisher</p><p>Publisher是一个可以提供0-N个序列元素的提供者，并根据其订阅者<code>Subscriber&lt;? super T&gt;</code>的需求推送元素。</p><p>一个Publisher可以支持多个订阅者，并可以根据订阅者的逻辑进行推送序列元素。</p><p>下面这个<strong>Excel</strong>计算就能说明一些Publisher的特点。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/image-20241217163334529.png" alt="image-20241217163334529"></p><p><strong>A1-A9</strong>就可以看做Publisher及其提供的元素序列。</p><p><strong>A10-A13</strong>分别是求和函数<code>SUM(A1:A9)</code>、平均函数<code>AVERAGE(A1:A9)</code>、最大值函数<code>MAX(A1:A9)</code>、最小值函数<code>MIN(A1:A9)</code>，</p><p><strong>A10-A13</strong>可以看作订阅者<code>Subscriber</code>。</p><p>假如说我们没有<strong>A10-A13</strong>，那么<strong>A1-A9</strong>就没有实际意义，它们并不产生计算。</p><p>这也是响应式的一个重要特点：<strong>当没有订阅时发布者什么也不做</strong>。而Flux和Mono都是Publisher在<strong>Reactor3</strong>实现。</p><p>Publisher提供了<code>subscribe</code>方法，允许消费者在有结果可用时进行消费。</p><p>如果没有消费者Publisher不会做任何事情，他根据消费情况进行响应。</p><p>Publisher可能返回零或者多个，甚至可能是无限的，为了更加清晰表示期待的结果就引入了两个实现模型Mono和Flux。</p><h3 id="flux">Flux</h3><p>Flux是一个发出(emit)<code>0-N</code>个元素组成的异步序列的Publisher,可以被<code>onComplete</code>信号或者<code>onError</code>信号所终止。</p><p>在响应流规范中存在三种给下游消费者调用的方法 <code>onNext</code>,<code>onComplete</code>,和<code>onError</code>。下面这张图表示了Flux的抽象模型：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/39057f0084064329a48d28a49d627dd0.png" alt="img"></p><p>以上的的讲解对于初次接触反应式编程的依然是难以理解的，所以这里有一个循序渐进的理解过程。</p><h3 id="传统数据处理">传统数据处理</h3><p>我们在平常是这么写的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ClientUser&gt; <span class="title">allUsers</span>()</span> {</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> ClientUser(<span class="string">"felord.cn"</span>, <span class="string">"reactive"</span>),</span><br><span class="line">            <span class="keyword">new</span> ClientUser(<span class="string">"Felordcn"</span>, <span class="string">"Reactor"</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们通过迭代返回值<code>List</code>来<code>get</code>这些元素进行再处理（消费），不管有没有消费者，菜品都会生产出来。</p><h5 id="流式数据处理">流式数据处理</h5><p>在<strong>Java 8</strong>中我们可以改写为流的表示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stream&lt;ClientUser&gt; <span class="title">allUsers</span>()</span> {</span><br><span class="line">    <span class="keyword">return</span>  Stream.of(<span class="keyword">new</span> ClientUser(<span class="string">"felord.cn"</span>, <span class="string">"reactive"</span>),</span><br><span class="line">            <span class="keyword">new</span> ClientUser(<span class="string">"Felordcn"</span>, <span class="string">"Reactor"</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="反应式数据处理">反应式数据处理</h3><p>在<strong>Reactor</strong>中我们又可以改写为Flux表示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;ClientUser&gt; <span class="title">allUsers</span>()</span>{</span><br><span class="line">    <span class="keyword">return</span> Flux.just(<span class="keyword">new</span> ClientUser(<span class="string">"felord.cn"</span>, <span class="string">"reactive"</span>),</span><br><span class="line">            <span class="keyword">new</span> ClientUser(<span class="string">"Felordcn"</span>, <span class="string">"Reactor"</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这时候食客来了，发生了订阅，厨师才开始做。</p><p>官方文档：<a href="https://easywheelsoft.github.io/reactor-core-zh/index.html#flux">https://easywheelsoft.github.io/reactor-core-zh/index.html#flux</a></p><h3 id="flux-的创建demo">Flux 的创建Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Flux</span> <span class="variable">ints</span> <span class="operator">=</span> Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">Flux</span> <span class="variable">seq1</span> <span class="operator">=</span> Flux.just(<span class="string">"bole1"</span>, <span class="string">"bole2"</span>, <span class="string">"bole3"</span>);</span><br><span class="line"><span class="type">List</span> <span class="variable">iterable</span> <span class="operator">=</span> Arrays.asList(<span class="string">"bole_01"</span>, <span class="string">"bole_02"</span>, <span class="string">"bole_03"</span>);</span><br><span class="line"><span class="type">Flux</span> <span class="variable">seq2</span> <span class="operator">=</span> Flux.fromIterable(iterable);</span><br><span class="line">seq2.subscribe(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h3 id="mono">Mono</h3><p>Mono是一个发出(emit)<code>0-1</code>个元素的Publisher,可以被<code>onComplete</code>信号或者<code>onError</code>信号所终止。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/3e90551078964d84b3ecaa6326adac11.png" alt="img"></p><p>mono整体和Flux差不多，只不过这里只会发出0-1个元素。也就是说不是有就是没有。</p><p>象Flux一样，我们来看看Mono的演化过程以帮助理解。</p><h4 id="传统数据处理-1">传统数据处理</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClientUser <span class="title">currentUser</span> ()</span> {</span><br><span class="line">    <span class="keyword">return</span> isAuthenticated ? <span class="keyword">new</span> ClientUser(<span class="string">"felord.cn"</span>, <span class="string">"reactive"</span>) : <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>直接返回符合条件的对象或者null`。</p><h4 id="optional的处理方式">Optional的处理方式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;ClientUser&gt; <span class="title">currentUser</span> ()</span> {</span><br><span class="line">    <span class="keyword">return</span> isAuthenticated ? Optional.of(<span class="keyword">new</span> ClientUser(<span class="string">"felord.cn"</span>, <span class="string">"reactive"</span>))</span><br><span class="line">            : Optional.empty();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这个Optional我觉得就有反应式的那种味儿了，当然它并不是反应式。当我们不从返回值Optional取其中具体的对象时，我们不清楚里面到底有没有，但是Optional是一定客观存在的,不会出现<strong>NPE</strong>问题。</p><h4 id="反应式数据处理-1">反应式数据处理</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;ClientUser&gt; <span class="title">currentUser</span> ()</span> {</span><br><span class="line">    <span class="keyword">return</span> isAuthenticated ? Mono.just(<span class="keyword">new</span> ClientUser(<span class="string">"felord.cn"</span>, <span class="string">"reactive"</span>))</span><br><span class="line">            : Mono.empty();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>和Optional有点类似的机制，当然Mono不是为了解决<strong>NPE</strong>问题的，它是为了处理响应流中单个值（也可能是<code>Void</code>）而存在的。</p><h3 id="mono的创建demo">Mono的创建Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mono</span> <span class="variable">data</span> <span class="operator">=</span> Mono.just(<span class="string">"bole"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Mono</span> <span class="variable">noData</span> <span class="operator">=</span> Mono.empty();</span><br><span class="line"></span><br><span class="line">m.subscribe(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h3 id="flux和mono总结">Flux和Mono总结</h3><p>Flux和Mono是<strong>Java</strong>反应式中的重要概念，但是很多同学包括我在开始都难以理解它们。这其实是规定了两种流式范式，这种范式让数据具有一些新的特性，比如基于发布订阅的事件驱动，异步流、背压等等。另外数据是推送（<strong>Push</strong>）给消费者的以区别于平时我们的拉（<strong>Pull</strong>）模式。同时我们可以像<a href="https://links.jianshu.com/go?to=https%3A%2F%2Ffelord.cn%2Fjava8streamapi.html">StreamApi</a>一样使用类似`map`、<code>flatmap</code>等操作符（<strong>operator</strong>）来操作它们。</p><h2 id="函数编程">函数编程</h2><p>反应式编程，常常和函数式编程结合，这就是让大家困扰的地方</p><h3 id="函数编程接口">函数编程接口</h3><table><thead><tr class="header"><th>接口函数名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>BiConsumer</td><td>表示接收两个输入参数和不返回结果的操作。</td></tr><tr class="even"><td>BiFunction</td><td>表示接受两个参数，并产生一个结果的函数。</td></tr><tr class="odd"><td>BinaryOperator</td><td>表示在相同类型的两个操作数的操作，生产相同类型的操作数的结果。</td></tr><tr class="even"><td>BiPredicate</td><td>代表两个参数谓词（布尔值函数）。</td></tr><tr class="odd"><td>BooleanSupplier</td><td>代表布尔值结果的提供者。</td></tr><tr class="even"><td>Consumer</td><td>表示接受一个输入参数和不返回结果的操作。</td></tr><tr class="odd"><td>DoubleBinaryOperator</td><td>代表在两个double值操作数的运算，并产生一个double值结果。</td></tr><tr class="even"><td>DoubleConsumer</td><td>表示接受一个double值参数，不返回结果的操作。</td></tr><tr class="odd"><td>DoubleFunction</td><td>表示接受double值参数，并产生一个结果的函数。</td></tr><tr class="even"><td>DoublePredicate</td><td>代表一个double值参数谓词（布尔值函数）。</td></tr><tr class="odd"><td>DoubleSupplier</td><td>表示表示接受double值参数，并产生一个结果的函数。值结果的提供者。</td></tr><tr class="even"><td>DoubleToIntFunction</td><td>表示接受一个double值参数，不返回结果的操作。</td></tr><tr class="odd"><td>DoubleFunction</td><td>表示接受double值参数，并产生一个结果的函数。</td></tr><tr class="even"><td>DoublePredicate</td><td>代表一个double值参数谓词（布尔值函数）。</td></tr><tr class="odd"><td>DoubleSupplier</td><td>DoubleToIntFunction</td></tr><tr class="even"><td>DoubleToIntFunction</td><td>表示接受double值参数，并产生一个int值结果的函数。</td></tr><tr class="odd"><td>DoubleToLongFunction</td><td>表示上产生一个double值结果的单个double值操作数的操作。</td></tr><tr class="even"><td>Function</td><td>代表接受一个double值参数，并产生一个long值结果的函数。</td></tr><tr class="odd"><td>DoubleUnaryOperator</td><td>表示上产生一个double值结果的单个double值操作数的操作。</td></tr><tr class="even"><td>Function</td><td>表示接受一个参数，并产生一个结果的函数。</td></tr><tr class="odd"><td>IntConsumer</td><td>表示接受单个int值的参数并没有返回结果的操作。</td></tr><tr class="even"><td>IntFunction</td><td>表示接受一个int值参数，并产生一个结果的函数。</td></tr><tr class="odd"><td>IntPredicate</td><td>表示一个整数值参数谓词（布尔值函数）。</td></tr><tr class="even"><td>IntSupplier</td><td>代表整型值的结果的提供者。</td></tr><tr class="odd"><td>IntToLongFunction</td><td>表示接受一个int值参数，并产生一个long值结果的函数。</td></tr><tr class="even"><td>IntUnaryOperator</td><td>表示产生一个int值结果的单个int值操作数的运算。</td></tr><tr class="odd"><td>LongBinaryOperator</td><td>表示在两个long值操作数的操作，并产生一个ObjLongConsumer值结果。</td></tr><tr class="even"><td>LongFunction</td><td>表示接受long值参数，并产生一个结果的函数。</td></tr><tr class="odd"><td>LongPredicate</td><td>代表一个long值参数谓词（布尔值函数）。</td></tr><tr class="even"><td>LongSupplier</td><td>表示long值结果的提供者。</td></tr><tr class="odd"><td>LongToDoubleFunction</td><td>表示接受double参数，并产生一个double值结果的函数。</td></tr><tr class="even"><td>LongToIntFunction</td><td>表示接受long值参数，并产生一个int值结果的函数。</td></tr><tr class="odd"><td>LongUnaryOperator</td><td>表示上产生一个long值结果单一的long值操作数的操作。</td></tr><tr class="even"><td>ObjDoubleConsumer</td><td>表示接受对象值和double值参数，并且没有返回结果的操作。</td></tr><tr class="odd"><td>ObjIntConsumer</td><td>表示接受对象值和整型值参数，并返回没有结果的操作。</td></tr><tr class="even"><td>ObjLongConsumer</td><td>表示接受对象值和整型值参数，并返回没有结果的操作。</td></tr><tr class="odd"><td>ObjLongConsumer</td><td>表示接受对象值和double值参数，并且没有返回结果的操作。</td></tr><tr class="even"><td>ObjIntConsumer</td><td>表示接受对象值和整型值参数，并返回没有结果的操作。</td></tr><tr class="odd"><td>ObjLongConsumer</td><td>表示接受对象的值和long值的说法，并没有返回结果的操作。</td></tr><tr class="even"><td>Predicate</td><td>代表一个参数谓词（布尔值函数）。</td></tr><tr class="odd"><td>Supplier</td><td>表示一个提供者的结果。</td></tr><tr class="even"><td>ToDoubleBiFunction</td><td>表示接受两个参数，并产生一个double值结果的功能。</td></tr><tr class="odd"><td>ToDoubleFunction</td><td>代表一个产生一个double值结果的功能。</td></tr><tr class="even"><td>ToIntBiFunction</td><td>表示接受两个参数，并产生一个int值结果的函数。</td></tr><tr class="odd"><td>ToIntFunction</td><td>代表产生一个int值结果的功能。</td></tr><tr class="even"><td>ToLongBiFunction</td><td>表示接受两个参数，并产生long值结果的功能。</td></tr><tr class="odd"><td>ToLongFunction</td><td>代表一个产生long值结果的功能。</td></tr><tr class="even"><td>UnaryOperator</td><td>表示上产生相同类型的操作数的结果的单个操作数的操作。</td></tr></tbody></table><h3 id="常用函数编程示例">常用函数编程示例</h3><p>Consumer 一个输入 无输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Product product=<span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"><span class="comment">//类名+静态方法  一个输入T 没有输出</span></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> Product-&gt;Product.nameOf(product);<span class="comment">//lambda</span></span><br><span class="line">consumer1.accept(product);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> Product::nameOf;<span class="comment">//方法引用</span></span><br><span class="line">consumer.accept(product);</span><br></pre></td></tr></table></figure><p>Funtion&lt;T,R&gt; 一个输入 一个输出</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对象+方法  一个输入T 一个输出R</span><br><span class="line"><span class="keyword">Function</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt; <span class="keyword">function</span> = product::reduceStock;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"剩余库存："</span> + <span class="keyword">function</span>.apply(<span class="number">10</span>));</span><br><span class="line">//带参数的构造函数</span><br><span class="line"><span class="keyword">Function</span>&lt;<span class="built_in">Integer</span>,Product&gt; function1=Product::<span class="keyword">new</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"新对象:"</span> +function1.apply(<span class="number">200</span>));</span><br></pre></td></tr></table></figure><p>Predicate 一个输入T, 一个输出 Boolean</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Predicate 一个输入T 一个输出Boolean</span></span><br><span class="line">Predicate predicate= i -&gt; product.isEnough(i);<span class="comment">//lambda</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"库存是否足够："</span>+predicate.test(<span class="number">100</span>));</span><br><span class="line">Predicate predicate1= product::isEnough;<span class="comment">//方法引用</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"库存是否足够："</span>+predicate1.test(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>UnaryOperator 一元操作符 输入输出都是T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一元操作符  输入和输出T</span></span><br><span class="line">UnaryOperator integerUnaryOperator =product::reduceStock;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"剩余库存："</span> + integerUnaryOperator.apply(<span class="number">20</span>));</span><br><span class="line">IntUnaryOperator intUnaryOperator = product::reduceStock;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"剩余库存："</span> + intUnaryOperator.applyAsInt(<span class="number">30</span>));</span><br></pre></td></tr></table></figure><p>Supplier 没有输入 只有输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数构造函数</span></span><br><span class="line">Supplier supplier = Product::<span class="built_in">new</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"创建新对象:"</span> + supplier.get());</span><br><span class="line">Supplier supplier1=()-&gt;product.getStock();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"剩余库存:"</span> + supplier1.get());</span><br></pre></td></tr></table></figure><p>BiFunction 二元操作符 两个输入&lt;T,U&gt; 一个输出</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//类名+方法</span><br><span class="line">BiFunction&lt;Product, <span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt; binaryOperator = Product::reduceStock;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">" 剩余库存(BiFunction)："</span> + binaryOperator.apply(product, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>BinaryOperator 二元操作符 ,二个输入 一个输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BinaryOperator binaryOperator1=(x,y)-&gt;product.reduceStock(x,y);</span></span><br><span class="line">BinaryOperator binaryOperator1=product::reduceStock;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">" 剩余库存(BinaryOperator)："</span> +binaryOperator<span class="number">1.</span><span class="built_in">apply</span>(product.<span class="built_in">getStock</span>(),<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h2 id="flux类中的静态方法">Flux类中的静态方法：</h2><h3 id="简单的创建方法">简单的创建方法</h3><p><strong>just</strong>()：</p><p>可以指定序列中包含的全部元素。创建出来的Flux序列在发布这些元素之后会自动结束</p><p><strong>fromArray()，fromIterable()，fromStream()：</strong></p><p>可以从一个数组，Iterable对象或Stream对象中穿件Flux对象</p><p><strong>empty</strong>()：</p><p>创建一个不包含任何元素，只发布结束消息的序列</p><p><strong>error</strong>(Throwable error)：</p><p>创建一个只包含错误消息的序列</p><p><strong>never</strong>()：</p><p>传建一个不包含任务消息通知的序列</p><p><strong>range(int start, int count)：</strong></p><p>创建包含从start起始的count个数量的Integer对象的序列</p><p><strong>interval(Duration period)和interval(Duration delay, Durationperiod)：</strong></p><p>创建一个包含了从0开始递增的Long对象的序列。其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间</p><p><strong>intervalMillis(long period)和intervalMillis(long delay, longperiod)：</strong></p><p>与interval()方法相同，但该方法通过毫秒数来指定时间间隔和延迟时间</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/intervalWithDelay.svg" alt="img"></p><p>例子</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.just</span>("Hello", "World")<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.fromArray</span>(new Integer[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>})<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.empty</span>()<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">10</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.interval</span>(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS))<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.intervalMillis</span>(<span class="number">1000</span>)<span class="selector-class">.subscirbe</span>(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="复杂的序列创建-generate">复杂的序列创建 generate()</h3><p>当序列的生成需要复杂的逻辑时，则应该使用generate()或create()方法。</p><p>generate()方法通过同步和逐一的方式来产生Flux序列。</p><p>序列的产生是通过调用所提供的的SynchronousSink对象的next()，complete()和error(Throwable)方法来完成的。</p><p>逐一生成的含义是在具体的生成逻辑中，next()方法只能最多被调用一次。</p><p>在某些情况下，序列的生成可能是有状态的，需要用到某些状态对象，此时可以使用</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span>(Callable&lt;S&gt; stateSupplier, BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt; generator)，</span><br></pre></td></tr></table></figure><p>其中stateSupplier用来提供初始的状态对象。</p><p>在进行序列生成时，状态对象会作为generator使用的第一个参数传入，可以在对应的逻辑中对改状态对象进行修改以供下一次生成时使用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Flux.<span class="title function_ invoke__">generate</span>(sink -&gt; {</span><br><span class="line">  sink.<span class="title function_ invoke__">next</span>(<span class="string">"Hello"</span>);</span><br><span class="line">  sink.<span class="title function_ invoke__">complete</span>();  </span><br><span class="line">}).<span class="title function_ invoke__">subscribe</span>(System.out::<span class="variable constant_">println</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Random random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">Flux.<span class="title function_ invoke__">generate</span>(<span class="title class_">ArrayList</span>::<span class="variable constant_">new</span>, (<span class="keyword">list</span>, sink) -&gt; {</span><br><span class="line">  <span class="keyword">int</span> value = random.<span class="title function_ invoke__">nextInt</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">list</span>.<span class="title function_ invoke__">add</span>(value);</span><br><span class="line">  sink.<span class="title function_ invoke__">next</span>(value);</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">list</span>.<span class="title function_ invoke__">size</span>() ==<span class="number">10</span>) {</span><br><span class="line">     sink.<span class="title function_ invoke__">complete</span>();  </span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">list</span>;</span><br><span class="line">}).<span class="title function_ invoke__">subscribe</span>(System.out::<span class="variable constant_">println</span>);</span><br></pre></td></tr></table></figure><h3 id="复杂的序列创建-create">复杂的序列创建 create()</h3><p>create()方法与generate()方法的不同之处在于所使用的是FluxSink对象。</p><p>FluxSink支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.create</span>(sink -&gt; {</span><br><span class="line">    for (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) {</span><br><span class="line">       sink<span class="selector-class">.next</span>(i);</span><br><span class="line">    }</span><br><span class="line">  sink<span class="selector-class">.complete</span>();</span><br><span class="line">})<span class="selector-class">.subscribe</span>(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="mono静态方法">Mono静态方法</h2><p>Mono类包含了与Flux类中相同的静态方法：just()，empty()和never()等。</p><p>除此之外，Mono还有一些独有的静态方法：</p><ul><li>fromCallable()，fromCompletionStage()，fromFuture()，fromRunnable()和fromSupplier()：分别从Callable，CompletionStage，CompletableFuture，Runnable和Supplier中创建Mono</li><li>delay(Duration duration)和delayMillis(longduration)：创建一个Mono序列，在指定的延迟时间之后，产生数字0作为唯一值</li><li>ignoreElements(Publishersource)：创建一个Mono序列，忽略作为源的Publisher中的所有元素，只产生消息</li><li>justOrEmpty(Optional&lt;? extends T&gt; data)和justOrEmpty(Tdata)：从一个Optional对象或可能为null的对象中创建Mono。只有Optional对象中包含之或对象不为null时，Mono序列才产生对应的元素</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mono.<span class="title function_ invoke__">fromSupplier</span>(() <span class="punctuation">-&gt;</span> <span class="string">"Hello"</span>).<span class="title function_ invoke__">subscribe</span>(System.out::println);</span><br><span class="line">Mono.<span class="title function_ invoke__">justOrEmpty</span>(Optional.<span class="title function_ invoke__">of</span>(<span class="string">"Hello"</span>)).<span class="title function_ invoke__">subscribe</span>(System.out::println);</span><br><span class="line">Mono.<span class="title function_ invoke__">create</span>(sink <span class="punctuation">-&gt;</span> sink.<span class="title function_ invoke__">success</span>(<span class="string">"Hello"</span>)).<span class="title function_ invoke__">subscribte</span>(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="操作符">操作符</h2><p>建议配合图解观看比较容易理解：<a href="https://projectreactor.io/docs/core/release/api/">https://projectreactor.io/docs/core/release/api/</a></p><h3 id="操作符buffer和buffertimeout">操作符buffer和bufferTimeout</h3><p>这两个操作符的作用是把当前流中的元素收集到集合中，并把集合对象作为流中的新元素。</p><p>在进行收集时可以指定不同的条件：所包含的元素的最大数量或收集的时间间隔。方法buffer()仅使用一个条件，而bufferTimeout()可以同时指定两个条件。</p><p>指定时间间隔时可以使用Duration对象或毫秒数，即使用bufferMillis()或bufferTimeoutMillis()两个方法。</p><p>除了元素数量和时间间隔外，还可以通过bufferUntil和bufferWhile操作符来进行收集。这两个操作符的参数时表示每个集合中的元素索要满足的条件的Predicate对象。</p><p>bufferUntil会一直收集直到Predicate返回true。</p><p>使得Predicate返回true的那个元素可以选择添加到当前集合或下一个集合中；bufferWhile则只有当Predicate返回true时才会收集。一旦为false，会立即开始下一次收集。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">100</span>)<span class="selector-class">.buffer</span>(<span class="number">20</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.intervalMillis</span>(<span class="number">100</span>)<span class="selector-class">.bufferMillis</span>(<span class="number">1001</span>)<span class="selector-class">.take</span>(<span class="number">2</span>)<span class="selector-class">.toStream</span>()<span class="selector-class">.forEach</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">10</span>)<span class="selector-class">.bufferUntil</span>(i -&gt; i%<span class="number">2</span> == <span class="number">0</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">10</span>)<span class="selector-class">.bufferWhile</span>(i -&gt; i%<span class="number">2</span> == <span class="number">0</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符filter">操作符Filter</h3><p>对流中包含的元素进行过滤，只留下满足Predicate指定条件的元素。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">10</span>)<span class="selector-class">.filter</span>(i -&gt; i%<span class="number">2</span> == <span class="number">0</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符zipwith">操作符zipWith</h3><p>zipWith操作符把当前流中的元素与另一个流中的元素按照一对一的方式进行合并。在合并时可以不做任何处理，由此得到的是一个元素类型为Tuple2的流；也可以通过一个BiFunction函数对合并的元素进行处理，所得到的流的元素类型为该函数的返回值。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux.<span class="keyword">just("a", </span><span class="string">"b"</span>).zipWith(Flux.<span class="keyword">just("c", </span><span class="string">"d"</span>)).<span class="keyword">subscribe(System.out::println);</span></span><br><span class="line"><span class="keyword"></span>Flux.<span class="keyword">just("a", </span><span class="string">"b"</span>).zipWith(Flux.<span class="keyword">just("c", </span><span class="string">"d"</span>), (<span class="built_in">s1</span>, <span class="built_in">s2</span>) -&gt; String.format(<span class="string">"%s-%s"</span>, <span class="built_in">s1</span>, <span class="built_in">s2</span>)).<span class="keyword">subscribe(System.out::println);</span></span><br></pre></td></tr></table></figure><h3 id="操作符take">操作符take</h3><p>take系列操作符用来从当前流中提取元素。提取方式如下：</p><ul><li><p>take(long n)，take(Duration timespan)和takeMillis(longtimespan)：按照指定的数量或时间间隔来提取</p></li><li><p>takeLast(long n)：提取流中的最后N个元素</p></li><li><p>takeUntil(Predicate&lt;? super T&gt; predicate)：提取元素直到Predicate返回true</p></li><li><p>takeWhile(Predicate&lt;? super T&gt;continuePredicate)：当Predicate返回true时才进行提取</p></li><li><p>takeUntilOther(Publisher&lt;?&gt;other)：提取元素直到另外一个流开始产生元素</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">1000</span>)<span class="selector-class">.take</span>(<span class="number">10</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">1000</span>)<span class="selector-class">.takeLast</span>(<span class="number">10</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">1000</span>)<span class="selector-class">.takeWhile</span>(i -&gt; i &lt; <span class="number">10</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">1000</span>)<span class="selector-class">.takeUntil</span>(i -&gt; i == <span class="number">10</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符reduce和reducewith">操作符reduce和reduceWith</h3><p>reduce和reduceWith操作符对流中包含的所有元素进行运算操作，得到一个包含计算结果的Mono序列。运算操作是通过一个BiFunction来表示的，标识前后两个相邻元素。reduceWith需要在操作时可以指定一个初始值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">100</span>)<span class="selector-class">.reduce</span>((x, y) -&gt; <span class="attribute">x</span> + <span class="attribute">y</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.range</span>(<span class="number">1</span>, <span class="number">100</span>)<span class="selector-class">.reduceWith</span>(() -&gt; <span class="number">100</span>, (x, y) -&gt; <span class="attribute">x</span> + <span class="attribute">y</span>)<span class="selector-class">.subscribe</span>(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符merge和mergesequential">操作符merge和mergeSequential</h3><p>merge和mergeSequential操作符用来把多个流合并成一个Flux序列。merge按照所有流中元素的实际产生序列来合并，而mergeSequential按照所有流被订阅的顺序（串行），以流为单位进行合并。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.merge</span>(Flux.intervalMillis(<span class="number">0</span>, <span class="number">100</span>)<span class="selector-class">.take</span>(<span class="number">5</span>), Flux<span class="selector-class">.intervalMillis</span>(<span class="number">50</span>, <span class="number">100</span>)<span class="selector-class">.take</span>(<span class="number">5</span>))<span class="selector-class">.toStream</span>()<span class="selector-class">.forEach</span>(System.out::println);</span><br><span class="line">Flux<span class="selector-class">.mergeSequential</span>(Flux.intervalMillis(<span class="number">0</span>, <span class="number">100</span>)<span class="selector-class">.take</span>(<span class="number">5</span>), Flux<span class="selector-class">.intervalMillis</span>(<span class="number">50</span>, <span class="number">100</span>)<span class="selector-class">.take</span>(<span class="number">5</span>))<span class="selector-class">.toStream</span>()<span class="selector-class">.forEach</span>(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符flatmap和flatmapsequential">操作符flatMap和flatMapSequential</h3><p>flatMap和flatMapSequential操作符把流中的每个元素通过BiFunction指定转换成一个流，再把所有流中的元素进行合并merge。flatMap并发的订阅了它的内部发布者，flatMapSequential和flatMap之间的区别与mergeSequential和merge是一样的。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.just</span>(<span class="number">5</span>, <span class="number">10</span>)<span class="selector-class">.flatMap</span>(x -&gt; Flux.intervalMillis(x * <span class="number">10</span>, <span class="number">100</span>)<span class="selector-class">.take</span>(x))<span class="selector-class">.toStream</span>()<span class="selector-class">.forEach</span>(System.out::println);</span><br></pre></td></tr></table></figure><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/flatMapSequential.svg" alt="img"></p><h3 id="操作符concatmap">操作符concatMap</h3><p>concatMap操作符的作用也是把流中的每个元素转换成一个流，再把所有流进行合并。concatMap会根据原始流中的元素顺序依次把转换之后的流进行合并，并且concatMap堆转换之后的流的订阅是动态进行的，而flatMapSequential在合并之前就已经订阅了所有的流。</p><p><img src="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/doc-files/marbles/concatMap.svg" alt="img"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.just</span>(<span class="number">5</span>, <span class="number">10</span>)<span class="selector-class">.concatMap</span>(x -&gt; Flux.intervalMillis(x * <span class="number">10</span>, <span class="number">100</span>)<span class="selector-class">.take</span>(x))<span class="selector-class">.toStream</span>()<span class="selector-class">.forEach</span>(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符combinelatest">操作符combineLatest</h3><p>combineLatest操作符把所有流中的最新产生的元素合并成一个新的元素，作为返回结果流中的元素。只要其中任何一个流中产生了新的元素，合并操作就会被执行一次，结果流中就会产生新的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.combineLatest</span>(Arrays::toString, Flux.<span class="built_in">intervalMillis</span>(<span class="number">100</span>).<span class="built_in">take</span>(<span class="number">5</span>), Flux.<span class="built_in">intervalMillis</span>(<span class="number">50</span>, <span class="number">100</span>).<span class="built_in">take</span>(<span class="number">5</span>)).<span class="built_in">toStream</span>().<span class="built_in">forEach</span>(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="消息处理">消息处理</h2><p>当需要处理Flux或Mono中的消息时，可以通过subscribe方法来添加相应的订阅逻辑。</p><p>在调用subscribe方法时可以指定需要处理的消息类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>).concatWith(Mono.<span class="type">error</span>(<span class="built_in">new</span> IllegalStateException())).subscribe(System.out::<span class="built_in">println</span>, System.err::<span class="built_in">println</span>);</span><br><span class="line"></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>).concatWith(Mono.<span class="type">error</span>(<span class="built_in">new</span> IllegalStateException())).onErrorReturn(<span class="number">0</span>).subscribe(System.out::<span class="built_in">println</span>);</span><br></pre></td></tr></table></figure><p>第2种可以通过switchOnError()方法来使用另外的流来产生元素。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.just</span>(<span class="number">1</span>, <span class="number">2</span>)<span class="selector-class">.concatWith</span>(Mono.error(new IllegalStateException()))<span class="selector-class">.switchOnError</span>(Mono.just(<span class="number">0</span>))<span class="selector-class">.subscribe</span>(System.out::println);</span><br></pre></td></tr></table></figure><p>第3种是通过onErrorResumeWith()方法来根据不同的异常类型来选择要使用的产生元素的流。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.just</span>(<span class="number">1</span>, <span class="number">2</span>)<span class="selector-class">.concatWith</span>(Mono.error(new IllegalArgumentException()))<span class="selector-class">.onErrorResumeWith</span>(e -&gt; {</span><br><span class="line">  if(e instanceof IllegalStateException)</span><br><span class="line">    return Mono<span class="selector-class">.just</span>(<span class="number">0</span>);</span><br><span class="line">  else <span class="built_in">if</span>(e instanceof IllegalArgumentException)</span><br><span class="line">    return Mono<span class="selector-class">.just</span>(-<span class="number">1</span>);</span><br><span class="line">  return Mono<span class="selector-class">.epmty</span>();</span><br><span class="line">})<span class="selector-class">.subscribe</span>(System,.out::println);</span><br></pre></td></tr></table></figure><p>当出现错误时还可以使用retry操作符来进行重试。重试的动作是通过重新订阅序列来实现的。在使用retry操作时还可以指定重试的次数。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.just</span>(<span class="number">1</span>, <span class="number">2</span>)<span class="selector-class">.concatWith</span>(Mono.error(new IllegalStateException()))<span class="selector-class">.retry</span>(<span class="number">1</span>)<span class="selector-class">.subscrible</span>(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="调度器scheduler">调度器Scheduler</h2><p>通过调度器可以指定操作执行的方式和所在的线程。有以下几种不同的调度器实现</p><ul><li><p>当前线程，通过Schedulers.immediate()方法来创建</p></li><li><p>单一的可复用的线程，通过Schedulers.single()方法来创建</p></li><li><p>使用弹性的线程池，通过Schedulers.elastic()方法来创建。线程池中的线程是可以复用的。当所需要时，新的线程会被创建。若一个线程闲置时间太长，则会被销毁。该调度器适用于I/O操作相关的流的处理</p></li><li><p>使用对并行操作优化的线程池，通过Schedulers.parallel()方法来创建。其中的线程数量取决于CPU的核的数量。该调度器适用于计算密集型的流的处理</p></li><li><p>使用支持任务调度的调度器，通过Schedulers.timer()方法来创建</p></li><li><p>从已有的ExecutorService对象中创建调度器，通过Schedulers.fromExecutorService()方法来创建</p></li></ul><p>通过publishOn()和subscribeOn()方法可以切换执行操作调度器。publishOn()方法切换的是操作符的执行方式，而subscribeOn()方法切换的是产生流中元素时的执行方式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.create</span>(sink -&gt; {</span><br><span class="line">  sink.next(Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">  sink<span class="selector-class">.complete</span>();  </span><br><span class="line">})<span class="selector-class">.publishOn</span>(Schedulers.single())</span><br><span class="line"><span class="selector-class">.map</span>(x -&gt;  String.format("[%s] %s", Thread.currentThread()<span class="selector-class">.getName</span>(), <span class="attribute">x</span>))</span><br><span class="line"><span class="selector-class">.publishOn</span>(Schedulers.elastic())</span><br><span class="line"><span class="selector-class">.map</span>(x -&gt; String.format("[%s] %s", Thread.currentThread()<span class="selector-class">.getName</span>(), <span class="attribute">x</span>))</span><br><span class="line"><span class="selector-class">.subscribeOn</span>(Schedulers.parallel())</span><br><span class="line"><span class="selector-class">.toStream</span>()</span><br><span class="line"><span class="selector-class">.forEach</span>(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><p>StepVerifier的作用是可以对序列中包含的元素进行逐一验证。通过StepVerifier.create()方法对一个流进行包装之后再进行验证。expectNext()方法用来声明测试时所期待的流中的下一个元素的值，而verifyComplete()方法则验证流是否正常结束。verifyError()来验证流由于错误而终止。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier<span class="selector-class">.create</span>(Flux<span class="selector-class">.just</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>))<span class="selector-class">.expectNext</span>("<span class="selector-tag">a</span>")<span class="selector-class">.expectNext</span>("<span class="selector-tag">b</span>")<span class="selector-class">.verifyComplete</span>();</span><br></pre></td></tr></table></figure><p>使用StepVerifier.withVirtualTime()方法可以创建出使用虚拟时钟的SteoVerifier。通过thenAwait(Duration)方法可以让虚拟时钟前进。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier<span class="selector-class">.withVirtualTime</span>(() -&gt; Flux<span class="selector-class">.interval</span>(Duration.ofHours(<span class="number">4</span>), Duration<span class="selector-class">.ofDays</span>(<span class="number">1</span>))<span class="selector-class">.take</span>(<span class="number">2</span>))</span><br><span class="line">　<span class="selector-class">.expectSubscription</span>()</span><br><span class="line">　<span class="selector-class">.expectNoEvent</span>(Duration.ofHours(<span class="number">4</span>))</span><br><span class="line">　<span class="selector-class">.expectNext</span>(<span class="number">0</span>L)</span><br><span class="line">　<span class="selector-class">.thenAwait</span>(Duration.ofDays(<span class="number">1</span>))</span><br><span class="line">　<span class="selector-class">.expectNext</span>(<span class="number">1</span>L)</span><br><span class="line">　<span class="selector-class">.verifyComplete</span>();</span><br></pre></td></tr></table></figure><p>TestPublisher的作用在于可以控制流中元素的产生，甚至是违反反应流规范的情况。通过create()方法创建一个新的TestPublisher对象，然后使用next()方法来产生元素，使用complete()方法来结束流。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final TestPublisher&lt;String&gt; testPublisher = TestPublisher.creater();</span><br><span class="line">testPublisher.<span class="built_in">next</span>(<span class="string">"a"</span>);</span><br><span class="line">testPublisher.<span class="built_in">next</span>(<span class="string">"b"</span>);</span><br><span class="line">testPublisher.complete();</span><br><span class="line"></span><br><span class="line">StepVerifier.<span class="built_in">create</span>(testPublisher)</span><br><span class="line">    .expectNext(<span class="string">"a"</span>)</span><br><span class="line">    .expectNext(<span class="string">"b"</span>)</span><br><span class="line">    .expectComplete();</span><br></pre></td></tr></table></figure><h2 id="调试">调试</h2><p>在调试模式启用之后，所有的操作符在执行时都会保存额外的与执行链相关的信息。当出现错误时，这些信息会被作为异常堆栈信息的一部分输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hooks.<span class="title function_ invoke__">onOperator</span>(providedHook <span class="punctuation">-&gt;</span> providedHook.<span class="title function_ invoke__">operatorStacktrace</span>());</span><br></pre></td></tr></table></figure><p>也可以通过checkpoint操作符来对特定的流处理链来启用调试模式。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux<span class="selector-class">.just</span>(<span class="number">1</span>, <span class="number">0</span>)<span class="selector-class">.map</span>(x -&gt; <span class="number">1</span>/x)<span class="selector-class">.checkpoint</span>("test")<span class="selector-class">.subscribe</span>(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="日志记录">日志记录</h2><p>可以通过添加log操作把流相关的事件记录在日志中，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.<span class="keyword">range</span>(<span class="number">1</span>, <span class="number">2</span>).log(<span class="string">"Range"</span>).subscribe(System.out::<span class="built_in">println</span>);</span><br></pre></td></tr></table></figure><h2 id="冷热序列">冷热序列</h2><p>冷序列的含义是不论订阅者在何时订阅该序列，总是能收到序列中产生的全部消息。热序列是在持续不断的产生消息，订阅者只能获取到在其订阅之后产生的消息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Flux&lt;<span class="built_in">Long</span>&gt; source = Flux.intervalMillis(<span class="number">1000</span>).take(<span class="number">10</span>).publish.autoConnect();</span><br><span class="line">source.subscribe();</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">source.toStream().forEach(System.<span class="keyword">out</span>::println);</span><br></pre></td></tr></table></figure><h2 id="serverwebexchange交换机">ServerWebExchange交换机</h2><h3 id="serverwebexchange与过滤器的关系"><code>ServerWebExchange</code>与过滤器的关系：</h3><p>Spring Cloud Gateway同zuul类似，有“pre”和“post”两种方式的filter。</p><p>客户端的请求先经过“pre”类型的filter，然后将请求转发到具体的业务服务，收到业务服务的响应之后，再经过“post”类型的filter处理，最后返回响应到客户端。</p><p>引用Spring Cloud Gateway官网上的一张图： <a href="https://user-images.githubusercontent.com/13992911/131647702-23c2f0c9-cca2-4ebb-b08c-5469d44b1434.png"><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/2d635bf4a46b1657d8bb15fc3a178e88.png" alt="image"></a></p><p>与zuul不同的是，filter除了分为“pre”和“post”两种方式的filter外，在SpringCloud Gateway中，filter从作用范围可分为另外两种，</p><p>一种是<strong>针对于单个路由的gatewayfilter</strong>，它在配置文件中的写法同predict类似；</p><p>一种是<strong>针对于所有路由的global gateway filer</strong>。</p><p>现在从作用范围划分的维度来讲解这两种filter。</p><p>我们在使用<code>Spring Cloud Gateway</code>的时候，注意到过滤器（包括<code>GatewayFilter</code>、<code>GlobalFilter</code>和过滤器链<code>GatewayFilterChain</code>）。</p><p>Spring CloudGateway根据作用范围划分为GatewayFilter和GlobalFilter，二者区别如下：</p><ul><li><strong>GatewayFilter</strong> : 需要通过spring.cloud.routes.filters配置在具体路由下，只作用在当前路由上或通过spring.cloud.default-filters配置在全局，作用在所有路由上</li><li><strong>GlobalFilter</strong> :全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</li></ul><p>Spring Cloud Gateway框架内置的GlobalFilter如下：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/dca13dad83c3ab4c45d433ed66699d1c.png" alt="img"></p><p>上图中每一个GlobalFilter都作用在每一个router上，能够满足大多数的需求。</p><p>但是如果遇到业务上的定制，可能需要编写满足自己需求的GlobalFilter。</p><p>过滤器都依赖到<code>ServerWebExchange</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> {</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GatewayFilter</span> <span class="keyword">extends</span> <span class="title class_">ShortcutConfigurable</span> {</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GatewayFilterChain</span> {</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange)</span>;</span><br><span class="line">}    </span><br></pre></td></tr></table></figure><p>这里的设计和<code>Servlet</code>中的<code>Filter</code>是相似的，</p><p>当前过滤器可以决定是否执行下一个过滤器的逻辑，由<code>GatewayFilterChain#filter()</code>是否被调用来决定。</p><p>而<code>ServerWebExchange</code>就相当于当前请求和响应的上下文。</p><p><code>ServerWebExchange</code>实例不单存储了<code>Request</code>和<code>Response</code>对象，还提供了一些扩展方法，如果想实现改造请求参数或者响应参数，就必须深入了解<code>ServerWebExchange</code>。</p><h3 id="理解serverwebexchange">理解ServerWebExchange</h3><p>先看<code>ServerWebExchange</code>的注释：</p><blockquote><p>Contract for an HTTP request-response interaction.</p><p>Provides access to the HTTP request and response and also exposesadditional server-side processing related properties and features suchas request attributes.</p></blockquote><p>翻译一下大概是：</p><blockquote><p>ServerWebExchange是一个HTTP请求-响应交互的契约。提供对HTTP请求和响应的访问，并公开额外的服务器端处理相关属性和特性，如请求属性。</p></blockquote><p>其实，<code>ServerWebExchange</code>命名为<strong>服务网络交换器</strong>，存放着重要的请求-响应属性、请求实例和响应实例等等，有点像<code>Context</code>的角色。</p><h3 id="serverwebexchange接口">ServerWebExchange接口</h3><p><code>ServerWebExchange</code>接口的所有方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="title class_">ServerWebExchange</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志前缀属性的KEY，值为org.springframework.web.server.ServerWebExchange.LOG_ID</span></span><br><span class="line">    <span class="comment">// 可以理解为 attributes.set("org.springframework.web.server.ServerWebExchange.LOG_ID","日志前缀的具体值");</span></span><br><span class="line">    <span class="comment">// 作用是打印日志的时候会拼接这个KEY对饮的前缀值，默认值为""</span></span><br><span class="line">    <span class="title class_">String</span> <span class="variable constant_">LOG_ID_ATTRIBUTE</span> = <span class="title class_">ServerWebExchange</span>.<span class="property">class</span>.<span class="title function_">getName</span>() + <span class="string">".LOG_ID"</span>;</span><br><span class="line">    <span class="title class_">String</span> <span class="title function_">getLogPrefix</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ServerHttpRequest对象</span></span><br><span class="line">    <span class="title class_">ServerHttpRequest</span> <span class="title function_">getRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ServerHttpResponse对象</span></span><br><span class="line">    <span class="title class_">ServerHttpResponse</span> <span class="title function_">getResponse</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前exchange的请求属性，返回结果是一个可变的Map</span></span><br><span class="line">    <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; <span class="title function_">getAttributes</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据KEY获取请求属性</span></span><br><span class="line">    @<span class="title class_">Nullable</span></span><br><span class="line">    <span class="keyword">default</span> &lt;T&gt; T <span class="title function_">getAttribute</span>(<span class="params"><span class="built_in">String</span> name</span>) {</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="title function_">getAttributes</span>().<span class="title function_">get</span>(name);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据KEY获取请求属性，做了非空判断</span></span><br><span class="line">    @<span class="title class_">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">default</span> &lt;T&gt; T <span class="title function_">getRequiredAttribute</span>(<span class="params"><span class="built_in">String</span> name</span>) {</span><br><span class="line">        T value = <span class="title function_">getAttribute</span>(name);</span><br><span class="line">        <span class="title class_">Assert</span>.<span class="title function_">notNull</span>(value, () -&gt; <span class="string">"Required attribute '"</span> + name + <span class="string">"' is missing"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 根据KEY获取请求属性，需要提供默认值</span></span><br><span class="line">    @<span class="title class_">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">default</span> &lt;T&gt; T <span class="title function_">getAttributeOrDefault</span>(<span class="params"><span class="built_in">String</span> name, T defaultValue</span>) {</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="title function_">getAttributes</span>().<span class="title function_">getOrDefault</span>(name, defaultValue);</span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前请求的网络会话</span></span><br><span class="line">    <span class="title class_">Mono</span>&lt;<span class="title class_">WebSession</span>&gt; <span class="title function_">getSession</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前请求的认证用户，如果存在的话</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Principal</span>&gt; <span class="title class_">Mono</span>&lt;T&gt; <span class="title function_">getPrincipal</span>();  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回请求的表单数据或者一个空的Map，只有Content-Type为application/x-www-form-urlencoded的时候这个方法才会返回一个非空的Map -- 这个一般是表单数据提交用到</span></span><br><span class="line">    <span class="title class_">Mono</span>&lt;<span class="title class_">MultiValueMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt;&gt; <span class="title function_">getFormData</span>();   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回multipart请求的part数据或者一个空的Map，只有Content-Type为multipart/form-data的时候这个方法才会返回一个非空的Map  -- 这个一般是文件上传用到</span></span><br><span class="line">    <span class="title class_">Mono</span>&lt;<span class="title class_">MultiValueMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">Part</span>&gt;&gt; <span class="title function_">getMultipartData</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回Spring的上下文</span></span><br><span class="line">    @<span class="title class_">Nullable</span></span><br><span class="line">    <span class="title class_">ApplicationContext</span> <span class="title function_">getApplicationContext</span>();   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这几个方法和lastModified属性相关</span></span><br><span class="line">    boolean <span class="title function_">isNotModified</span>();</span><br><span class="line">    boolean <span class="title function_">checkNotModified</span>(<span class="title class_">Instant</span> lastModified);</span><br><span class="line">    boolean <span class="title function_">checkNotModified</span>(<span class="title class_">String</span> etag);</span><br><span class="line">    boolean <span class="title function_">checkNotModified</span>(@<span class="title class_">Nullable</span> <span class="title class_">String</span> etag, <span class="title class_">Instant</span> lastModified);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// URL转换</span></span><br><span class="line">    <span class="title class_">String</span> <span class="title function_">transformUrl</span>(<span class="title class_">String</span> url);    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// URL转换映射</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUrlTransformer</span>(<span class="title class_">Function</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt; transformer); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这个方法，方法名是：改变，这个是修改ServerWebExchange属性的方法，返回的是一个Builder实例，Builder是ServerWebExchange的内部类</span></span><br><span class="line">    <span class="keyword">default</span> <span class="title class_">Builder</span> <span class="title function_">mutate</span>(<span class="params"></span>) {</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultServerWebExchangeBuilder</span>(<span class="variable language_">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    interface <span class="title class_">Builder</span> {      </span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 覆盖ServerHttpRequest</span></span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">request</span>(<span class="title class_">Consumer</span>&lt;<span class="title class_">ServerHttpRequest</span>.<span class="property">Builder</span>&gt; requestBuilderConsumer);</span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">request</span>(<span class="title class_">ServerHttpRequest</span> request);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 覆盖ServerHttpResponse</span></span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">response</span>(<span class="title class_">ServerHttpResponse</span> response);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 覆盖当前请求的认证用户</span></span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">principal</span>(<span class="title class_">Mono</span>&lt;<span class="title class_">Principal</span>&gt; principalMono);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 构建新的ServerWebExchange实例</span></span><br><span class="line">        <span class="title class_">ServerWebExchange</span> <span class="title function_">build</span>();</span><br><span class="line">    }</span><br><span class="line">}    </span><br></pre></td></tr></table></figure><h3 id="serverwebexchangemutate方法"><code>ServerWebExchange#mutate()</code>方法</h3><p>注意到<code>ServerWebExchange#mutate()</code>方法，<code>ServerWebExchange</code>实例可以理解为不可变实例，</p><p>如果我们想要修改它，需要通过<code>mutate()</code>方法生成一个新的实例，例如这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">CustomGlobalFilter</span> implements <span class="title class_">GlobalFilter</span> {</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">filter</span>(<span class="params">ServerWebExchange exchange, GatewayFilterChain chain</span>) {</span><br><span class="line">        <span class="title class_">ServerHttpRequest</span> request = exchange.<span class="title function_">getRequest</span>();</span><br><span class="line">        <span class="comment">// 这里可以修改ServerHttpRequest实例</span></span><br><span class="line">        <span class="title class_">ServerHttpRequest</span> newRequest = ...</span><br><span class="line">        <span class="title class_">ServerHttpResponse</span> response = exchange.<span class="title function_">getResponse</span>();</span><br><span class="line">        <span class="comment">// 这里可以修改ServerHttpResponse实例</span></span><br><span class="line">        <span class="title class_">ServerHttpResponse</span> newResponse = ...</span><br><span class="line">        <span class="comment">// 构建新的ServerWebExchange实例</span></span><br><span class="line">        <span class="title class_">ServerWebExchange</span> newExchange = exchange.<span class="title function_">mutate</span>().<span class="title function_">request</span>(newRequest).<span class="title function_">response</span>(newResponse).<span class="title function_">build</span>();</span><br><span class="line">        <span class="keyword">return</span> chain.<span class="title function_">filter</span>(newExchange);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="serverhttprequest接口">ServerHttpRequest接口</h3><p><code>ServerHttpRequest</code>实例是用于承载请求相关的属性和请求体，</p><p><code>Spring Cloud Gateway</code>中底层使用<code>Netty</code>处理网络请求，通过追溯源码，</p><p>可以从<code>ReactorHttpHandlerAdapter</code>中得知<code>ServerWebExchange</code>实例中持有的<code>ServerHttpRequest</code>实例的具体实现是<code>ReactorServerHttpRequest</code>。</p><p>之所以列出这些实例之间的关系，是因为这样比较容易理清一些隐含的问题，例如：</p><ul><li><strong><code>ReactorServerHttpRequest</code>的父类<code>AbstractServerHttpRequest</code>中初始化内部属性headers的时候把请求的HTTP头部封装为只读的实例</strong>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="title class_">AbstractServerHttpRequest</span>(<span class="variable constant_">URI</span> uri, @<span class="title class_">Nullable</span> <span class="title class_">String</span> contextPath, <span class="title class_">HttpHeaders</span> headers) {</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">uri</span> = uri;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">path</span> = <span class="title class_">RequestPath</span>.<span class="title function_">parse</span>(uri, contextPath);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">headers</span> = <span class="title class_">HttpHeaders</span>.<span class="title function_">readOnlyHttpHeaders</span>(headers);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpHeaders类中的readOnlyHttpHeaders方法，</span></span><br><span class="line"><span class="comment">// ReadOnlyHttpHeaders屏蔽了所有修改请求头的方法，直接抛出UnsupportedOperationException</span></span><br><span class="line">public <span class="keyword">static</span> <span class="title class_">HttpHeaders</span> <span class="title function_">readOnlyHttpHeaders</span>(<span class="params">HttpHeaders headers</span>) {</span><br><span class="line"><span class="title class_">Assert</span>.<span class="title function_">notNull</span>(headers, <span class="string">"HttpHeaders must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (headers <span class="keyword">instanceof</span> <span class="title class_">ReadOnlyHttpHeaders</span>) {</span><br><span class="line"><span class="keyword">return</span> headers;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyHttpHeaders</span>(headers);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>所以,<strong>不能直接从<code>ServerHttpRequest</code>实例中直接获取请求头<code>HttpHeaders</code>实例并且进行修改</strong>。</p><p><code>ServerHttpRequest</code>接口如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="title class_">HttpMessage</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取请求头，目前的实现中返回的是ReadOnlyHttpHeaders实例，只读</span></span><br><span class="line">    <span class="title class_">HttpHeaders</span> <span class="title function_">getHeaders</span>();</span><br><span class="line">}    </span><br><span class="line"></span><br><span class="line">public interface <span class="title class_">ReactiveHttpInputMessage</span> <span class="keyword">extends</span> <span class="title class_">HttpMessage</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回请求体的Flux封装</span></span><br><span class="line">    <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; <span class="title function_">getBody</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public interface <span class="title class_">HttpRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpMessage</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回HTTP请求方法，解析为HttpMethod实例</span></span><br><span class="line">    @<span class="title class_">Nullable</span></span><br><span class="line">    <span class="keyword">default</span> <span class="title class_">HttpMethod</span> <span class="title function_">getMethod</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">HttpMethod</span>.<span class="title function_">resolve</span>(<span class="title function_">getMethodValue</span>());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回HTTP请求方法，字符串</span></span><br><span class="line">    <span class="title class_">String</span> <span class="title function_">getMethodValue</span>();    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求的URI</span></span><br><span class="line">    <span class="variable constant_">URI</span> <span class="title function_">getURI</span>();</span><br><span class="line">}    </span><br><span class="line"></span><br><span class="line">public interface <span class="title class_">ServerHttpRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpRequest</span>, <span class="title class_">ReactiveHttpInputMessage</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接的唯一标识或者用于日志处理标识</span></span><br><span class="line">    <span class="title class_">String</span> <span class="title function_">getId</span>();   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取请求路径，封装为RequestPath对象</span></span><br><span class="line">    <span class="title class_">RequestPath</span> <span class="title function_">getPath</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回查询参数，是只读的MultiValueMap实例</span></span><br><span class="line">    <span class="title class_">MultiValueMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt; <span class="title function_">getQueryParams</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Cookie集合，是只读的MultiValueMap实例</span></span><br><span class="line">    <span class="title class_">MultiValueMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">HttpCookie</span>&gt; <span class="title function_">getCookies</span>();  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 远程服务器地址信息</span></span><br><span class="line">    @<span class="title class_">Nullable</span></span><br><span class="line">    <span class="keyword">default</span> <span class="title class_">InetSocketAddress</span> <span class="title function_">getRemoteAddress</span>(<span class="params"></span>) {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSL会话实现的相关信息</span></span><br><span class="line">    @<span class="title class_">Nullable</span></span><br><span class="line">    <span class="keyword">default</span> <span class="title class_">SslInfo</span> <span class="title function_">getSslInfo</span>(<span class="params"></span>) {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改请求的方法，返回一个建造器实例Builder，Builder是内部类</span></span><br><span class="line">    <span class="keyword">default</span> <span class="title class_">ServerHttpRequest</span>.<span class="property">Builder</span> <span class="title function_">mutate</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultServerHttpRequestBuilder</span>(<span class="variable language_">this</span>);</span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line">    interface <span class="title class_">Builder</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖请求方法</span></span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">method</span>(<span class="title class_">HttpMethod</span> httpMethod);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 覆盖请求的URI、请求路径或者上下文，这三者相互有制约关系，具体可以参考API注释</span></span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">uri</span>(<span class="variable constant_">URI</span> uri);</span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">path</span>(<span class="title class_">String</span> path);</span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">contextPath</span>(<span class="title class_">String</span> contextPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖请求头</span></span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">header</span>(<span class="title class_">String</span> key, <span class="title class_">String</span> value);</span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">headers</span>(<span class="title class_">Consumer</span>&lt;<span class="title class_">HttpHeaders</span>&gt; headersConsumer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 覆盖SslInfo</span></span><br><span class="line">        <span class="title class_">Builder</span> <span class="title function_">sslInfo</span>(<span class="title class_">SslInfo</span> sslInfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建一个新的ServerHttpRequest实例</span></span><br><span class="line">        <span class="title class_">ServerHttpRequest</span> <span class="title function_">build</span>();</span><br><span class="line">    }         </span><br><span class="line">}    </span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerHttpRequest`或者说`HttpMessage`接口提供的获取请求头方法`HttpHeaders getHeaders();</span><br></pre></td></tr></table></figure><p>返回结果是一个只读的实例，具体是<code>ReadOnlyHttpHeaders</code>类型，</p><p>如果要修改<code>ServerHttpRequest</code>实例，那么需要这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">newRequest</span> <span class="operator">=</span> request.mutate().header(<span class="string">"key"</span>,<span class="string">"value"</span>).path(<span class="string">"/myPath"</span>).build();</span><br></pre></td></tr></table></figure><h3 id="serverhttpresponse接口">ServerHttpResponse接口</h3><p><code>ServerHttpResponse</code>实例是用于承载响应相关的属性和响应体，</p><p><code>Spring Cloud Gateway</code>中底层使用<code>Netty</code>处理网络请求，通过追溯源码，可以从<code>ReactorHttpHandlerAdapter</code>中得知<code>ServerWebExchange</code>实例中持有的<code>ServerHttpResponse</code>实例的具体实现是<code>ReactorServerHttpResponse</code>。</p><p>之所以列出这些实例之间的关系，是因为这样比较容易理清一些隐含的问题，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactorServerHttpResponse的父类</span></span><br><span class="line">public <span class="title class_">AbstractServerHttpResponse</span>(<span class="title class_">DataBufferFactory</span> dataBufferFactory, <span class="title class_">HttpHeaders</span> headers) {</span><br><span class="line"><span class="title class_">Assert</span>.<span class="title function_">notNull</span>(dataBufferFactory, <span class="string">"DataBufferFactory must not be null"</span>);</span><br><span class="line"><span class="title class_">Assert</span>.<span class="title function_">notNull</span>(headers, <span class="string">"HttpHeaders must not be null"</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">dataBufferFactory</span> = dataBufferFactory;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">headers</span> = headers;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cookies</span> = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public <span class="title class_">ReactorServerHttpResponse</span>(<span class="title class_">HttpServerResponse</span> response, <span class="title class_">DataBufferFactory</span> bufferFactory) {</span><br><span class="line"><span class="variable language_">super</span>(bufferFactory, <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>(<span class="keyword">new</span> <span class="title class_">NettyHeadersAdapter</span>(response.<span class="title function_">responseHeaders</span>())));</span><br><span class="line"><span class="title class_">Assert</span>.<span class="title function_">notNull</span>(response, <span class="string">"HttpServerResponse must not be null"</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">response</span> = response;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>可知<code>ReactorServerHttpResponse</code>构造函数初始化实例的时候，存放响应Header的是<code>HttpHeaders</code>实例，也就是响应Header是可以直接修改的。</p><p><code>ServerHttpResponse</code>接口如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="title class_">HttpMessage</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取响应Header，目前的实现中返回的是HttpHeaders实例，可以直接修改</span></span><br><span class="line">    <span class="title class_">HttpHeaders</span> <span class="title function_">getHeaders</span>();</span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line">public interface <span class="title class_">ReactiveHttpOutputMessage</span> <span class="keyword">extends</span> <span class="title class_">HttpMessage</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取DataBufferFactory实例，用于包装或者生成数据缓冲区DataBuffer实例(创建响应体)</span></span><br><span class="line">    <span class="title class_">DataBufferFactory</span> <span class="title function_">bufferFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个动作，在HttpOutputMessage提交之前此动作会进行回调</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beforeCommit</span>(<span class="title class_">Supplier</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt;&gt; action);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断HttpOutputMessage是否已经提交</span></span><br><span class="line">    boolean <span class="title function_">isCommitted</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入消息体到HTTP协议层</span></span><br><span class="line">    <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">writeWith</span>(<span class="title class_">Publisher</span>&lt;? <span class="keyword">extends</span> <span class="title class_">DataBuffer</span>&gt; body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入消息体到HTTP协议层并且刷新缓冲区</span></span><br><span class="line">    <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">writeAndFlushWith</span>(<span class="title class_">Publisher</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Publisher</span>&lt;? <span class="keyword">extends</span> <span class="title class_">DataBuffer</span>&gt;&gt; body);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指明消息处理已经结束，一般在消息处理结束自动调用此方法，多次调用不会产生副作用</span></span><br><span class="line">    <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">setComplete</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public interface <span class="title class_">ServerHttpResponse</span> <span class="keyword">extends</span> <span class="title class_">ReactiveHttpOutputMessage</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置响应状态码</span></span><br><span class="line">    boolean <span class="title function_">setStatusCode</span>(@<span class="title class_">Nullable</span> <span class="title class_">HttpStatus</span> status);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取响应状态码</span></span><br><span class="line">    @<span class="title class_">Nullable</span></span><br><span class="line">    <span class="title class_">HttpStatus</span> <span class="title function_">getStatusCode</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取响应Cookie，封装为MultiValueMap实例，可以修改</span></span><br><span class="line">    <span class="title class_">MultiValueMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">ResponseCookie</span>&gt; <span class="title function_">getCookies</span>();  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加响应Cookie</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCookie</span>(<span class="title class_">ResponseCookie</span> cookie);  </span><br><span class="line">}    </span><br></pre></td></tr></table></figure><p>这里可以看到除了响应体比较难修改之外，其他的属性都是可变的。</p><h3 id="serverwebexchangeutils和上下文属性">ServerWebExchangeUtils和上下文属性</h3><p><code>ServerWebExchangeUtils</code>里面存放了很多静态公有的字符串KEY值</p><p>(<strong>这些字符串KEY的实际值是</strong><code>org.springframework.cloud.gateway.support.ServerWebExchangeUtils.</code>+ 下面任意的静态公有KEY)，</p><p>这些字符串KEY值一般是用于<code>ServerWebExchange</code>的属性(<code>Attribute</code>，见上文的<code>ServerWebExchange#getAttributes()</code>方法)的KEY，这些属性值都是有特殊的含义，在使用过滤器的时候如果时机适当可以直接取出来使用，下面逐个分析。</p><ul><li><code>PRESERVE_HOST_HEADER_ATTRIBUTE</code>：是否保存Host属性，值是布尔值类型，写入位置是<code>PreserveHostHeaderGatewayFilterFactory</code>，使用的位置是<code>NettyRoutingFilter</code>，作用是如果设置为true，HTTP请求头中的Host属性会写到底层Reactor-Netty的请求Header属性中。</li><li><code>CLIENT_RESPONSE_ATTR</code>：保存底层Reactor-Netty的响应对象，类型是<code>reactor.netty.http.client.HttpClientResponse</code>。</li><li><code>CLIENT_RESPONSE_CONN_ATTR</code>：保存底层Reactor-Netty的连接对象，类型是<code>reactor.netty.Connection</code>。</li><li><code>URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>：<code>PathRoutePredicateFactory</code>解析路径参数完成之后，把解析完成后的占位符KEY-路径Path映射存放在<code>ServerWebExchange</code>的属性中，KEY就是<code>URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>。</li><li><code>CLIENT_RESPONSE_HEADER_NAMES</code>：保存底层Reactor-Netty的响应Header的名称集合。</li><li><code>GATEWAY_ROUTE_ATTR</code>：用于存放<code>RoutePredicateHandlerMapping</code>中匹配出来的具体的路由(<code>org.springframework.cloud.gateway.route.Route</code>)实例，通过这个路由实例可以得知当前请求会路由到下游哪个服务。</li><li><code>GATEWAY_REQUEST_URL_ATTR</code>：<code>java.net.URI</code>类型的实例，这个实例代表直接请求或者<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>处理之后需要请求到下游服务的真实URI。</li><li><code>GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>：<code>java.net.URI</code>类型的实例，需要重写请求URI的时候，保存原始的请求URI。</li><li><code>GATEWAY_HANDLER_MAPPER_ATTR</code>：保存当前使用的<code>HandlerMapping</code>具体实例的类型简称(一般是字符串"RoutePredicateHandlerMapping")。</li><li><code>GATEWAY_SCHEME_PREFIX_ATTR</code>：确定目标路由URI中如果存在schemeSpecificPart属性，则保存该URI的scheme在此属性中，路由URI会被重新构造，见<code>RouteToRequestUrlFilter</code>。</li><li><code>GATEWAY_PREDICATE_ROUTE_ATTR</code>：用于存放<code>RoutePredicateHandlerMapping</code>中匹配出来的具体的路由(<code>org.springframework.cloud.gateway.route.Route</code>)实例的ID。</li><li><code>WEIGHT_ATTR</code>：实验性功能(此版本还不建议在正式版本使用)存放分组权重相关属性，见<code>WeightCalculatorWebFilter</code>。</li><li><code>ORIGINAL_RESPONSE_CONTENT_TYPE_ATTR</code>：存放响应Header中的ContentType的值。</li><li><code>HYSTRIX_EXECUTION_EXCEPTION_ATTR</code>：<code>Throwable</code>的实例，存放的是Hystrix执行异常时候的异常实例，见<code>HystrixGatewayFilterFactory</code>。</li><li><code>GATEWAY_ALREADY_ROUTED_ATTR</code>：布尔值，用于判断是否已经进行了路由，见<code>NettyRoutingFilter</code>。</li><li><code>GATEWAY_ALREADY_PREFIXED_ATTR</code>：布尔值，用于判断请求路径是否被添加了前置部分，见<code>PrefixPathGatewayFilterFactory</code>。</li></ul><p><code>ServerWebExchangeUtils</code>提供的上下文属性用于<code>Spring Cloud Gateway</code>的<code>ServerWebExchange</code>组件处理请求和响应的时候，内部一些重要实例或者标识属性的安全传输和使用，使用它们可能存在一定的风险，</p><p>因为没有人可以确定在版本升级之后，原有的属性KEY或者VALUE是否会发生改变，如果评估过风险或者规避了风险之后，可以安心使用。</p><p>例如我们**在做请求和响应日志(类似Nginx的AccessLog)的时候，可以依赖到<code>GATEWAY_ROUTE_ATTR</code>，因为我们要打印路由的目标信息。**举个简单例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Slf4</span>j</span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">AccessLogFilter</span> implements <span class="title class_">GlobalFilter</span> {</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">filter</span>(<span class="params">ServerWebExchange exchange, GatewayFilterChain chain</span>) {</span><br><span class="line">        <span class="title class_">ServerHttpRequest</span> request = exchange.<span class="title function_">getRequest</span>();</span><br><span class="line">        <span class="title class_">String</span> path = request.<span class="title function_">getPath</span>().<span class="title function_">pathWithinApplication</span>().<span class="title function_">value</span>();</span><br><span class="line">        <span class="title class_">HttpMethod</span> method = request.<span class="title function_">getMethod</span>();</span><br><span class="line">        <span class="comment">// 获取路由的目标URI</span></span><br><span class="line">        <span class="variable constant_">URI</span> targetUri = exchange.<span class="title function_">getAttribute</span>(<span class="title class_">ServerWebExchangeUtils</span>.<span class="property">GATEWAY_REQUEST_URL_ATTR</span>);</span><br><span class="line">        <span class="title class_">InetSocketAddress</span> remoteAddress = request.<span class="title function_">getRemoteAddress</span>();</span><br><span class="line">        <span class="keyword">return</span> chain.<span class="title function_">filter</span>(exchange.<span class="title function_">mutate</span>().<span class="title function_">build</span>()).<span class="title function_">then</span>(<span class="title class_">Mono</span>.<span class="title function_">fromRunnable</span>(() -&gt; {</span><br><span class="line">            <span class="title class_">ServerHttpResponse</span> response = exchange.<span class="title function_">getResponse</span>();</span><br><span class="line">            <span class="title class_">HttpStatus</span> statusCode = response.<span class="title function_">getStatusCode</span>();</span><br><span class="line">            log.<span class="title function_">info</span>(<span class="string">"请求路径:{},客户端远程IP地址:{},请求方法:{},目标URI:{},响应码:{}"</span>,</span><br><span class="line">                    path, remoteAddress, method, targetUri, statusCode);</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="修改请求体">修改请求体</h3><p>修改请求体是一个比较常见的需求。</p><p>例如我们使用<code>Spring Cloud Gateway</code>实现网关的时候，要实现一个功能：</p><blockquote><p>把存放在请求头中的JWT解析后，提取里面的用户ID，然后写入到请求体中。</p></blockquote><p>我们简化这个场景，假设我们把userId明文存放在请求头中的accessToken中，请求体是一个JSON结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="string">"serialNumber"</span>: <span class="string">"请求流水号"</span>,</span><br><span class="line">    <span class="string">"payload"</span> : {</span><br><span class="line">        <span class="comment">// ... 这里是有效载荷，存放具体的数据</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们需要提取accessToken，也就是userId插入到请求体JSON中如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="string">"userId"</span>: <span class="string">"用户ID"</span>,</span><br><span class="line">    <span class="string">"serialNumber"</span>: <span class="string">"请求流水号"</span>,</span><br><span class="line">    <span class="string">"payload"</span> : {</span><br><span class="line">        <span class="comment">// ... 这里是有效载荷，存放具体的数据</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里为了简化设计，用全局过滤器<code>GlobalFilter</code>实现，实际需要结合具体场景考虑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Slf4</span>j</span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">ModifyRequestBodyGlobalFilter</span> implements <span class="title class_">GlobalFilter</span> {</span><br><span class="line"></span><br><span class="line">    private final <span class="title class_">DataBufferFactory</span> dataBufferFactory = <span class="keyword">new</span> <span class="title class_">NettyDataBufferFactory</span>(<span class="title class_">ByteBufAllocator</span>.<span class="property">DEFAULT</span>);</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Autowired</span></span><br><span class="line">    private <span class="title class_">ObjectMapper</span> objectMapper;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">filter</span>(<span class="params">ServerWebExchange exchange, GatewayFilterChain chain</span>) {</span><br><span class="line">        <span class="title class_">ServerHttpRequest</span> request = exchange.<span class="title function_">getRequest</span>();</span><br><span class="line">        <span class="title class_">String</span> accessToken = request.<span class="title function_">getHeaders</span>().<span class="title function_">getFirst</span>(<span class="string">"accessToken"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">StringUtils</span>.<span class="title function_">hasLength</span>(accessToken)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"accessToken"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 新建一个ServerHttpRequest装饰器,覆盖需要装饰的方法</span></span><br><span class="line">        <span class="title class_">ServerHttpRequestDecorator</span> decorator = <span class="keyword">new</span> <span class="title class_">ServerHttpRequestDecorator</span>(request) {</span><br><span class="line"></span><br><span class="line">            @<span class="title class_">Override</span></span><br><span class="line">            public <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; <span class="title function_">getBody</span>(<span class="params"></span>) {</span><br><span class="line">                <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; body = <span class="variable language_">super</span>.<span class="title function_">getBody</span>();</span><br><span class="line">                <span class="title class_">InputStreamHolder</span> holder = <span class="keyword">new</span> <span class="title class_">InputStreamHolder</span>();</span><br><span class="line">                body.<span class="title function_">subscribe</span>(buffer -&gt; holder.<span class="property">inputStream</span> = buffer.<span class="title function_">asInputStream</span>());</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != holder.<span class="property">inputStream</span>) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 解析JSON的节点</span></span><br><span class="line">                        <span class="title class_">JsonNode</span> jsonNode = objectMapper.<span class="title function_">readTree</span>(holder.<span class="property">inputStream</span>);</span><br><span class="line">                        <span class="title class_">Assert</span>.<span class="title function_">isTrue</span>(jsonNode <span class="keyword">instanceof</span> <span class="title class_">ObjectNode</span>, <span class="string">"JSON格式异常"</span>);</span><br><span class="line">                        <span class="title class_">ObjectNode</span> objectNode = (<span class="title class_">ObjectNode</span>) jsonNode;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// JSON节点最外层写入新的属性</span></span><br><span class="line">                        objectNode.<span class="title function_">put</span>(<span class="string">"userId"</span>, accessToken);</span><br><span class="line">                        <span class="title class_">DataBuffer</span> dataBuffer = dataBufferFactory.<span class="title function_">allocateBuffer</span>();</span><br><span class="line">                        <span class="title class_">String</span> json = objectNode.<span class="title function_">toString</span>();</span><br><span class="line">                        log.<span class="title function_">info</span>(<span class="string">"最终的JSON数据为:{}"</span>, json);</span><br><span class="line">                        dataBuffer.<span class="title function_">write</span>(json.<span class="title function_">getBytes</span>(<span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>));</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">return</span> <span class="title class_">Flux</span>.<span class="title function_">just</span>(dataBuffer);</span><br><span class="line">                    } <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getBody</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 使用修改后的ServerHttpRequestDecorator重新生成一个新的ServerWebExchange</span></span><br><span class="line">        <span class="keyword">return</span> chain.<span class="title function_">filter</span>(exchange.<span class="title function_">mutate</span>().<span class="title function_">request</span>(decorator).<span class="title function_">build</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">class</span> <span class="title class_">InputStreamHolder</span> {</span><br><span class="line"></span><br><span class="line">        <span class="title class_">InputStream</span> inputStream;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTTP</span></span><br><span class="line"><span class="variable constant_">POST</span> /order/json <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="attr">localhost</span>:<span class="number">9090</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="attr">accessToken</span>: <span class="number">10086</span></span><br><span class="line"><span class="title class_">Accept</span>: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">Cache-Control: no-cache</span></span><br><span class="line"><span class="comment">Host: localhost:9090</span></span><br><span class="line"><span class="comment">accept-encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">content-length: 94</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">cache-control: no-cache</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    "serialNumber": "请求流水号",</span></span><br><span class="line"><span class="comment">    "payload": {</span></span><br><span class="line"><span class="comment">        "name": "doge"</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 日志输出</span></span><br><span class="line"><span class="comment">最终的JSON数据为:{"serialNumber":"请求流水号","payload":{"name":"doge"},"userId":"10086"}</span></span><br></pre></td></tr></table></figure><p>最重要的是用到了<code>ServerHttpRequest</code>装饰器<code>ServerHttpRequestDecorator</code>，主要覆盖对应获取请求体数据缓冲区的方法即可，至于怎么处理其他逻辑需要自行考虑，这里只是做一个简单的示范。</p><p>一般的代码逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ServerHttpRequest</span> request = exchange.<span class="title function_">getRequest</span>();</span><br><span class="line"><span class="title class_">ServerHttpRequestDecorator</span> requestDecorator = <span class="keyword">new</span> <span class="title class_">ServerHttpRequestDecorator</span>(request) {</span><br><span class="line"></span><br><span class="line">     @<span class="title class_">Override</span></span><br><span class="line">     public <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; <span class="title function_">getBody</span>(<span class="params"></span>) {</span><br><span class="line">         <span class="comment">// 拿到承载原始请求体的Flux</span></span><br><span class="line">         <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; body = <span class="variable language_">super</span>.<span class="title function_">getBody</span>();</span><br><span class="line">         <span class="comment">// 这里通过自定义方式生成新的承载请求体的Flux</span></span><br><span class="line">         <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; newBody = ...</span><br><span class="line">         <span class="keyword">return</span> newBody;</span><br><span class="line">     }            </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> chain.<span class="title function_">filter</span>(exchange.<span class="title function_">mutate</span>().<span class="title function_">request</span>(requestDecorator).<span class="title function_">build</span>());    </span><br></pre></td></tr></table></figure><h3 id="修改响应体">修改响应体</h3><p>修改响应体的需求也是比较常见的，具体的做法和修改请求体差不多。</p><p>例如我们想要实现下面的功能：第三方服务请求经过网关，原始报文是密文，我们需要在网关实现密文解密，然后把解密后的明文路由到下游服务，下游服务处理成功响应明文，需要在网关把明文加密成密文再返回到第三方服务。</p><p>现在简化整个流程，用AES加密算法，统一密码为字符串"throwable"，假设请求报文和响应报文明文如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求密文</span></span><br><span class="line">{</span><br><span class="line">    <span class="string">"serialNumber"</span>: <span class="string">"请求流水号"</span>,</span><br><span class="line">    <span class="string">"payload"</span> : <span class="string">"加密后的请求消息载荷"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求明文（仅仅作为提示）</span></span><br><span class="line">{</span><br><span class="line">    <span class="string">"serialNumber"</span>: <span class="string">"请求流水号"</span>,</span><br><span class="line">    <span class="string">"payload"</span> : <span class="string">"{\"name:\":\"doge\"}"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应密文</span></span><br><span class="line">{</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="string">"payload"</span> : <span class="string">"加密后的响应消息载荷"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应明文（仅仅作为提示）</span></span><br><span class="line">{</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="string">"payload"</span> : <span class="string">"{\"name:\":\"doge\",\"age\":26}"</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>为了方便一些加解密或者编码解码的实现，需要引入<code>Apache</code>的<code>commons-codec</code>类库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里定义一个全局过滤器专门处理加解密，实际上最好结合真实的场景决定是否适合全局过滤器，这里只是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AES加解密工具类</span></span><br><span class="line">public enum <span class="title class_">AesUtils</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line">    X;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="title class_">String</span> <span class="variable constant_">PASSWORD</span> = <span class="string">"throwable"</span>;</span><br><span class="line">    private <span class="keyword">static</span> final <span class="title class_">String</span> <span class="variable constant_">KEY_ALGORITHM</span> = <span class="string">"AES"</span>;</span><br><span class="line">    private <span class="keyword">static</span> final <span class="title class_">String</span> <span class="variable constant_">SECURE_RANDOM_ALGORITHM</span> = <span class="string">"SHA1PRNG"</span>;</span><br><span class="line">    private <span class="keyword">static</span> final <span class="title class_">String</span> <span class="variable constant_">DEFAULT_CIPHER_ALGORITHM</span> = <span class="string">"AES/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">encrypt</span>(<span class="params"><span class="built_in">String</span> content</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="title class_">Cipher</span> cipher = <span class="title class_">Cipher</span>.<span class="title function_">getInstance</span>(<span class="variable constant_">DEFAULT_CIPHER_ALGORITHM</span>);</span><br><span class="line">            cipher.<span class="title function_">init</span>(<span class="title class_">Cipher</span>.<span class="property">ENCRYPT_MODE</span>, <span class="title function_">provideSecretKey</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Hex</span>.<span class="title function_">encodeHexString</span>(cipher.<span class="title function_">doFinal</span>(content.<span class="title function_">getBytes</span>(<span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>)));</span><br><span class="line">        } <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public byte[] <span class="title function_">decrypt</span>(<span class="params"><span class="built_in">String</span> content</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="title class_">Cipher</span> cipher = <span class="title class_">Cipher</span>.<span class="title function_">getInstance</span>(<span class="variable constant_">DEFAULT_CIPHER_ALGORITHM</span>);</span><br><span class="line">            cipher.<span class="title function_">init</span>(<span class="title class_">Cipher</span>.<span class="property">DECRYPT_MODE</span>, <span class="title function_">provideSecretKey</span>());</span><br><span class="line">            <span class="keyword">return</span> cipher.<span class="title function_">doFinal</span>(<span class="title class_">Hex</span>.<span class="title function_">decodeHex</span>(content));</span><br><span class="line">        } <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="title class_">SecretKey</span> <span class="title function_">provideSecretKey</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="title class_">KeyGenerator</span> keyGen = <span class="title class_">KeyGenerator</span>.<span class="title function_">getInstance</span>(<span class="variable constant_">KEY_ALGORITHM</span>);</span><br><span class="line">            <span class="title class_">SecureRandom</span> secureRandom = <span class="title class_">SecureRandom</span>.<span class="title function_">getInstance</span>(<span class="variable constant_">SECURE_RANDOM_ALGORITHM</span>);</span><br><span class="line">            secureRandom.<span class="title function_">setSeed</span>(<span class="variable constant_">PASSWORD</span>.<span class="title function_">getBytes</span>(<span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>));</span><br><span class="line">            keyGen.<span class="title function_">init</span>(<span class="number">128</span>, secureRandom);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(keyGen.<span class="title function_">generateKey</span>().<span class="title function_">getEncoded</span>(), <span class="variable constant_">KEY_ALGORITHM</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// EncryptionGlobalFilter</span></span><br><span class="line">@<span class="title class_">Slf4</span>j</span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">EncryptionGlobalFilter</span> implements <span class="title class_">GlobalFilter</span>, <span class="title class_">Ordered</span> {</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Autowired</span></span><br><span class="line">    private <span class="title class_">ObjectMapper</span> objectMapper;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public int <span class="title function_">getOrder</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">filter</span>(<span class="params">ServerWebExchange exchange, GatewayFilterChain chain</span>) {</span><br><span class="line">        <span class="title class_">ServerHttpRequest</span> request = exchange.<span class="title function_">getRequest</span>();</span><br><span class="line">        <span class="comment">// 响应体</span></span><br><span class="line">        <span class="title class_">ServerHttpResponse</span> response = exchange.<span class="title function_">getResponse</span>();</span><br><span class="line">        <span class="title class_">DataBufferFactory</span> bufferFactory = exchange.<span class="title function_">getResponse</span>().<span class="title function_">bufferFactory</span>();</span><br><span class="line">        <span class="title class_">ServerHttpRequestDecorator</span> requestDecorator = <span class="title function_">processRequest</span>(request, bufferFactory);</span><br><span class="line">        <span class="title class_">ServerHttpResponseDecorator</span> responseDecorator = <span class="title function_">processResponse</span>(response, bufferFactory);</span><br><span class="line">        <span class="keyword">return</span> chain.<span class="title function_">filter</span>(exchange.<span class="title function_">mutate</span>().<span class="title function_">request</span>(requestDecorator).<span class="title function_">response</span>(responseDecorator).<span class="title function_">build</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="title class_">ServerHttpRequestDecorator</span> <span class="title function_">processRequest</span>(<span class="params">ServerHttpRequest request, DataBufferFactory bufferFactory</span>) {</span><br><span class="line">        <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; body = request.<span class="title function_">getBody</span>();</span><br><span class="line">        <span class="title class_">DataBufferHolder</span> holder = <span class="keyword">new</span> <span class="title class_">DataBufferHolder</span>();</span><br><span class="line">        body.<span class="title function_">subscribe</span>(dataBuffer -&gt; {</span><br><span class="line">            int len = dataBuffer.<span class="title function_">readableByteCount</span>();</span><br><span class="line">            holder.<span class="property">length</span> = len;</span><br><span class="line">            byte[] bytes = <span class="keyword">new</span> byte[len];</span><br><span class="line">            dataBuffer.<span class="title function_">read</span>(bytes);</span><br><span class="line">            <span class="title class_">DataBufferUtils</span>.<span class="title function_">release</span>(dataBuffer);</span><br><span class="line">            <span class="title class_">String</span> text = <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>);</span><br><span class="line">            <span class="title class_">JsonNode</span> jsonNode = <span class="title function_">readNode</span>(text);</span><br><span class="line">            <span class="title class_">JsonNode</span> payload = jsonNode.<span class="title function_">get</span>(<span class="string">"payload"</span>);</span><br><span class="line">            <span class="title class_">String</span> payloadText = payload.<span class="title function_">asText</span>();</span><br><span class="line">            byte[] content = <span class="title class_">AesUtils</span>.<span class="property">X</span>.<span class="title function_">decrypt</span>(payloadText);</span><br><span class="line">            <span class="title class_">String</span> requestBody = <span class="keyword">new</span> <span class="title class_">String</span>(content, <span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>);</span><br><span class="line">            log.<span class="title function_">info</span>(<span class="string">"修改请求体payload,修改前:{},修改后:{}"</span>, payloadText, requestBody);</span><br><span class="line">            <span class="title function_">rewritePayloadNode</span>(requestBody, jsonNode);</span><br><span class="line">            <span class="title class_">DataBuffer</span> data = bufferFactory.<span class="title function_">allocateBuffer</span>();</span><br><span class="line">            data.<span class="title function_">write</span>(jsonNode.<span class="title function_">toString</span>().<span class="title function_">getBytes</span>(<span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>));</span><br><span class="line">            holder.<span class="property">dataBuffer</span> = data;</span><br><span class="line">        });</span><br><span class="line">        <span class="title class_">HttpHeaders</span> headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.<span class="title function_">putAll</span>(request.<span class="title function_">getHeaders</span>());</span><br><span class="line">        headers.<span class="title function_">remove</span>(<span class="title class_">HttpHeaders</span>.<span class="property">CONTENT_LENGTH</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerHttpRequestDecorator</span>(request) {</span><br><span class="line"></span><br><span class="line">            @<span class="title class_">Override</span></span><br><span class="line">            public <span class="title class_">HttpHeaders</span> <span class="title function_">getHeaders</span>(<span class="params"></span>) {</span><br><span class="line">                int contentLength = holder.<span class="property">length</span>;</span><br><span class="line">                <span class="keyword">if</span> (contentLength &gt; <span class="number">0</span>) {</span><br><span class="line">                    headers.<span class="title function_">setContentLength</span>(contentLength);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    headers.<span class="title function_">set</span>(<span class="title class_">HttpHeaders</span>.<span class="property">TRANSFER_ENCODING</span>, <span class="string">"chunked"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            @<span class="title class_">Override</span></span><br><span class="line">            public <span class="title class_">Flux</span>&lt;<span class="title class_">DataBuffer</span>&gt; <span class="title function_">getBody</span>(<span class="params"></span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Flux</span>.<span class="title function_">just</span>(holder.<span class="property">dataBuffer</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="title class_">ServerHttpResponseDecorator</span> <span class="title function_">processResponse</span>(<span class="params">ServerHttpResponse response, DataBufferFactory bufferFactory</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerHttpResponseDecorator</span>(response) {</span><br><span class="line"></span><br><span class="line">            @<span class="title class_">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            @<span class="title class_">Override</span></span><br><span class="line">            public <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">writeWith</span>(<span class="params">Publisher&lt;? <span class="keyword">extends</span> DataBuffer&gt; body</span>) {</span><br><span class="line">                <span class="keyword">if</span> (body <span class="keyword">instanceof</span> <span class="title class_">Flux</span>) {</span><br><span class="line">                    <span class="title class_">Flux</span>&lt;? <span class="keyword">extends</span> <span class="title class_">DataBuffer</span>&gt; flux = (<span class="title class_">Flux</span>&lt;? <span class="keyword">extends</span> <span class="title class_">DataBuffer</span>&gt;) body;</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">writeWith</span>(flux.<span class="title function_">map</span>(buffer -&gt; {</span><br><span class="line">                        <span class="title class_">CharBuffer</span> charBuffer = <span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>.<span class="title function_">decode</span>(buffer.<span class="title function_">asByteBuffer</span>());</span><br><span class="line">                        <span class="title class_">DataBufferUtils</span>.<span class="title function_">release</span>(buffer);</span><br><span class="line">                        <span class="title class_">JsonNode</span> jsonNode = <span class="title function_">readNode</span>(charBuffer.<span class="title function_">toString</span>());</span><br><span class="line">                        <span class="title class_">JsonNode</span> payload = jsonNode.<span class="title function_">get</span>(<span class="string">"payload"</span>);</span><br><span class="line">                        <span class="title class_">String</span> text = payload.<span class="title function_">toString</span>();</span><br><span class="line">                        <span class="title class_">String</span> content = <span class="title class_">AesUtils</span>.<span class="property">X</span>.<span class="title function_">encrypt</span>(text);</span><br><span class="line">                        log.<span class="title function_">info</span>(<span class="string">"修改响应体payload,修改前:{},修改后:{}"</span>, text, content);</span><br><span class="line">                        <span class="title function_">setPayloadTextNode</span>(content, jsonNode);</span><br><span class="line">                        <span class="keyword">return</span> bufferFactory.<span class="title function_">wrap</span>(jsonNode.<span class="title function_">toString</span>().<span class="title function_">getBytes</span>(<span class="title class_">StandardCharsets</span>.<span class="property">UTF_8</span>));</span><br><span class="line">                    }));</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">writeWith</span>(body);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="title function_">rewritePayloadNode</span>(<span class="params"><span class="built_in">String</span> text, JsonNode root</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="title class_">JsonNode</span> node = objectMapper.<span class="title function_">readTree</span>(text);</span><br><span class="line">            <span class="title class_">ObjectNode</span> objectNode = (<span class="title class_">ObjectNode</span>) root;</span><br><span class="line">            objectNode.<span class="title function_">set</span>(<span class="string">"payload"</span>, node);</span><br><span class="line">        } <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="title function_">setPayloadTextNode</span>(<span class="params"><span class="built_in">String</span> text, JsonNode root</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="title class_">ObjectNode</span> objectNode = (<span class="title class_">ObjectNode</span>) root;</span><br><span class="line">            objectNode.<span class="title function_">set</span>(<span class="string">"payload"</span>, <span class="keyword">new</span> <span class="title class_">TextNode</span>(text));</span><br><span class="line">        } <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="title class_">JsonNode</span> <span class="title function_">readNode</span>(<span class="params"><span class="built_in">String</span> <span class="keyword">in</span></span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> objectMapper.<span class="title function_">readTree</span>(<span class="keyword">in</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">class</span> <span class="title class_">DataBufferHolder</span> {</span><br><span class="line"></span><br><span class="line">        <span class="title class_">DataBuffer</span> dataBuffer;</span><br><span class="line">        int length;</span><br><span class="line">    }</span><br><span class="line">}  </span><br></pre></td></tr></table></figure><p>先准备一份密文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; json = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">json.<span class="title function_">put</span>(<span class="string">"serialNumber"</span>, <span class="string">"请求流水号"</span>);</span><br><span class="line"><span class="title class_">String</span> content = <span class="string">"{\"name\": \"doge\"}"</span>;</span><br><span class="line">json.<span class="title function_">put</span>(<span class="string">"payload"</span>, <span class="title class_">AesUtils</span>.<span class="property">X</span>.<span class="title function_">encrypt</span>(content));</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().<span class="title function_">writeValueAsString</span>(json));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">{<span class="string">"serialNumber"</span>:<span class="string">"请求流水号"</span>,<span class="string">"payload"</span>:<span class="string">"144e3dc734743f5709f1adf857bca473da683246fd612f86ac70edeb5f2d2729"</span>}</span><br></pre></td></tr></table></figure><p>模拟请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /order/json <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="attr">localhost</span>:<span class="number">9090</span></span><br><span class="line"><span class="attr">accessToken</span>: <span class="number">10086</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">PostmanRuntime</span>/<span class="number">7.13</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Accept</span>: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">Cache-Control: no-cache</span></span><br><span class="line"><span class="comment">Postman-Token: bda07fc3-ea1a-478c-b4d7-754fe6f37200,634734d9-feed-4fc9-ba20-7618bd986e1c</span></span><br><span class="line"><span class="comment">Host: localhost:9090</span></span><br><span class="line"><span class="comment">cookie: customCookieName=customCookieValue</span></span><br><span class="line"><span class="comment">accept-encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">content-length: 104</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">cache-control: no-cache</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    "serialNumber": "请求流水号",</span></span><br><span class="line"><span class="comment">    "payload": "FE49xzR0P1cJ8a34V7ykc9poMkb9YS+GrHDt618tJyk="</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 响应结果</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    "serialNumber": "请求流水号",</span></span><br><span class="line"><span class="comment">    "payload": "oo/K1igg2t/S8EExkBVGWOfI1gAh5pBpZ0wyjNPW6e8="   # &lt;--- 解密后：{"name":"doge","age":26}</span></span><br><span class="line"><span class="comment">}</span></span><br></pre></td></tr></table></figure><p>遇到的问题：</p><ul><li><strong>必须实现<code>Ordered</code>接口，返回一个小于-1的order值，这是因为<code>NettyWriteResponseFilter</code>的order值为-1</strong>，我们需要覆盖返回响应体的逻辑，自定义的<code>GlobalFilter</code>必须比<code>NettyWriteResponseFilter</code>优先执行。</li><li>网关每次重启之后，第一个请求总是无法从原始的<code>ServerHttpRequest</code>读取到有效的Body，准确来说出现的现象是<code>NettyRoutingFilter</code>调用<code>ServerHttpRequest#getBody()</code>的时候获取到一个空的对象，导致空指针；奇怪的是从第二个请求开始就能正常调用。<strong>笔者把</strong><code>**Spring Cloud Gateway**</code><strong>的版本降低到</strong><code>**Finchley.SR3**</code><strong>，</strong><code>**Spring Boot**</code><strong>的版本降低到</strong><code>**2.0.8.RELEASE**</code><strong>，问题不再出现，初步确定是</strong><code>**Spring Cloud Gateway**</code><strong>版本升级导致的兼容性问题或者是BUG</strong>。</li></ul><p>最重要的是用到了<code>ServerHttpResponse</code>装饰器<code>ServerHttpResponseDecorator</code>，主要覆盖写入响应体数据缓冲区的部分，至于怎么处理其他逻辑需要自行考虑，这里只是做一个简单的示范。一般的代码逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ServerHttpResponse</span> response = exchange.<span class="title function_">getResponse</span>();</span><br><span class="line"><span class="title class_">ServerHttpResponseDecorator</span> responseDecorator = <span class="keyword">new</span> <span class="title class_">ServerHttpResponseDecorator</span>(response) {</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">Mono</span>&lt;<span class="title class_">Void</span>&gt; <span class="title function_">writeWith</span>(<span class="params">Publisher&lt;? <span class="keyword">extends</span> DataBuffer&gt; body</span>) {</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> <span class="title class_">Flux</span>) {</span><br><span class="line">            <span class="title class_">Flux</span>&lt;? <span class="keyword">extends</span> <span class="title class_">DataBuffer</span>&gt; flux = (<span class="title class_">Flux</span>&lt;? <span class="keyword">extends</span> <span class="title class_">DataBuffer</span>&gt;) body;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">writeWith</span>(flux.<span class="title function_">map</span>(buffer -&gt; {</span><br><span class="line"><span class="comment">// buffer就是原始的响应数据的缓冲区</span></span><br><span class="line">            <span class="comment">// 下面处理完毕之后返回新的响应数据的缓冲区即可</span></span><br><span class="line">            <span class="keyword">return</span> bufferFactory.<span class="title function_">wrap</span>(...);</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">writeWith</span>(body);</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">return</span> chain.<span class="title function_">filter</span>(exchange.<span class="title function_">mutate</span>().<span class="title function_">response</span>(responseDecorator).<span class="title function_">build</span>());</span><br></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><p><a href="https://blog.csdn.net/wpc2018/article/details/122634049">https://blog.csdn.net/wpc2018/article/details/122634049</a><a href="https://www.jianshu.com/p/7d80b94068b3">https://www.jianshu.com/p/7d80b94068b3</a><a href="https://blog.csdn.net/yhj_911/article/details/119540000">https://blog.csdn.net/yhj_911/article/details/119540000</a><a href="http://bjqianye.cn/detail/6845.html">http://bjqianye.cn/detail/6845.html</a><a href="https://blog.csdn.net/hao134838/article/details/110824092">https://blog.csdn.net/hao134838/article/details/110824092</a><a href="https://blog.csdn.net/hao134838/article/details/110824092">https://blog.csdn.net/hao134838/article/details/110824092</a><a href="https://blog.csdn.net/weixin_34096182/article/details/91436704">https://blog.csdn.net/weixin_34096182/article/details/91436704</a><a href="https://blog.csdn.net/fly910905/article/details/121682625">https://blog.csdn.net/fly910905/article/details/121682625</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;响应式编程用的是越来越多，尤其是在移动端Android的应用上边&lt;/p&gt;
&lt;p&gt;在Java后台服务开发中， 响应式编程用的不是太广泛，主要原因是，
响应式编程需要一个完整的生态，
包括数据库、缓存、中间件，都需要配套的响应式组件，受到</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Java" scheme="https://www.junpengzhou.top/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.junpengzhou.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring5+的WebClient使用指南</title>
    <link href="https://www.junpengzhou.top/article/35b1d86e.html"/>
    <id>https://www.junpengzhou.top/article/35b1d86e.html</id>
    <published>2024-12-11T06:29:31.000Z</published>
    <updated>2024-12-11T06:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么使用webclient">为什么使用WebClient</h1><p>在 <strong>Spring Framework 5.0及更高版本</strong>中，<strong>RestTemplate已被标记废弃</strong>，取而代之的是较新的 WebClient。</p><blockquote><p>这意味着虽然 RestTemplate 仍然可用，但鼓励 Spring开发人员迁移到新项目的 WebClient。</p></blockquote><p>WebClient 优于 RestTemplate 的原因有几个：</p><ul><li><strong>非阻塞 I/O：</strong> WebClient 构建在 Reactor之上，它提供了一种<strong>非阻塞、反应式</strong>的方法来处理I/O，这可以在高流量应用程序中实现更好的可扩展性和更高的性能。</li><li><strong>函数式风格：</strong> WebClient<strong>使用函数式编程风格，可以使代码更易于阅读和理解</strong>。它还提供了流畅的API，可以<strong>更轻松地配置和自定义</strong>请求。</li><li><strong>更好地支持流式传输：</strong> WebClient支持请求和响应正文的流式传输，这对于处理大文件或实时数据非常有用。</li><li><strong>改进的错误处理：</strong> WebClient 提供比 RestTemplate更好的错误处理和日志记录，从而更轻松地诊断和解决问题。</li></ul><blockquote><p><strong>重点：即使升级了spring web6.0.0版本，也无法在HttpRequestFactory中设置请求超时，这是放弃使用RestTemplate 的最大因素之一。</strong></p></blockquote><p>总的来说，虽然 RestTemplate 可能仍然适用于某些用例，但 WebClient提供了几个优势，使其成为现代 Spring 应用程序的更好选择。</p><h1 id="springboot3应用程序中使用webclient">SpringBoot3应用程序中使用WebClient</h1><h5 id="创建网络客户端">创建网络客户端：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span></span><br><span class="line">        HttpClient.create()</span><br><span class="line">            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectionTimeout)</span><br><span class="line">            .responseTimeout(Duration.ofMillis(requestTimeout))</span><br><span class="line">            .doOnConnected(conn -&gt; conn.addHandlerLast(<span class="keyword">new</span> <span class="title class_">ReadTimeoutHandler</span>(readTimeout)));</span><br><span class="line"></span><br><span class="line">   <span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span></span><br><span class="line">        WebClient.builder().clientConnector(<span class="keyword">new</span> <span class="title class_">ReactorClientHttpConnector</span>(httpClient)).build();</span><br></pre></td></tr></table></figure><h5 id="同步发送请求就像resttemplate一样">同步发送请求（就像RestTemplate一样）</h5><p>如果你想坚持使用发送 HTTP 请求并等待响应的老方法，也可以使用WebClient 实现如下所示的相同功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postSynchronously</span><span class="params">(String url, String requestBody)</span> {</span><br><span class="line">  LOG.info(<span class="string">"Going to hit API - URL {} Body {}"</span>, url, requestBody);</span><br><span class="line">  <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    response =</span><br><span class="line">        client</span><br><span class="line">            .method(HttpMethod.POST)</span><br><span class="line">            .uri(url)</span><br><span class="line">            .accept(MediaType.ALL)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .bodyValue(requestBody)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(String.class)</span><br><span class="line">            .block();</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">    LOG.error(<span class="string">"Error while calling API "</span>, ex);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RunTimeException</span>(<span class="string">"XYZ service api error: "</span> + ex.getMessage());</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    LOG.info(<span class="string">"API Response {}"</span>, response);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>block()</code>用于同步等待响应，这可能并不适合所有情况，你可能需要考虑<code>subscribe()</code>异步使用和处理响应。</p><h5 id="异步发送请求">异步发送请求：</h5><p>有时我们不想等待响应，而是希望异步处理响应，这可以按如下方式完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Mono&lt;String&gt; <span class="title function_">makePostRequestAsync</span><span class="params">(String url, String postData)</span> {</span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder().build();</span><br><span class="line">    <span class="keyword">return</span> webClient.post()</span><br><span class="line">            .uri(url)</span><br><span class="line">            .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">            .body(BodyInserters.fromFormData(<span class="string">"data"</span>, postData))</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(String.class);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>要使用此函数，只需传入要向其发送 POST 请求的 URL 以及要在请求正文中以URL编码字符串形式发送的数据。该函数将返回来自服务器的响应，或者如果请求由于任何原因失败，则返回一条错误消息。</p><blockquote><p>请注意，在此示例中，WebClient是使用默认配置构建的。你可能需要根据不同要求进行不同的配置。</p><p>另请注意，block()用于同步等待响应，这可能并不适合所有情况。你可能需要考虑subscribe()异步使用和处理响应。</p></blockquote><p>要使用响应，您可以订阅（subscribe）Mono并异步处理响应。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">makePostRequestAsync(<span class="string">"https://example.com/api"</span>, <span class="string">"param1=value1&amp;m2=value2"</span>) </span><br><span class="line">.subscribe(response -&gt; { </span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    System.out.println(response); </span><br><span class="line">}, error -&gt; { </span><br><span class="line">    / / 处理错误</span><br><span class="line">    System.err.println(error.getMessage());     </span><br><span class="line">   }</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>subscribe()</code>用于异步处理响应，你可以提供两个 lambda表达式作为 <code>subscribe()</code>的参数。如果请求成功并收到响应作为参数，则执行第一个 lambda表达式；如果请求失败并收到错误作为参数，则执行第二个 lambda 表达式。</p><h5 id="处理4xx和5xx错误">处理4XX和5XX错误：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Mono&lt;String&gt; <span class="title function_">makePostRequestAsync</span><span class="params">(String url, String postData)</span> {</span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">            .baseUrl(url)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> webClient.post()</span><br><span class="line">            .uri(<span class="string">"/"</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">            .body(BodyInserters.fromFormData(<span class="string">"data"</span>, postData))</span><br><span class="line">            .retrieve()</span><br><span class="line">            .onStatus(HttpStatus::is4xxClientError, clientResponse -&gt; Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"Client error"</span>)))</span><br><span class="line">            .onStatus(HttpStatus::is5xxServerError, clientResponse -&gt; Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"Server error"</span>)))</span><br><span class="line">            .bodyToMono(String.class);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在此示例中，该<code>onStatus()</code>方法被调用两次，一次针对 4xx客户端错误，一次针对 5xx 服务器错误。<code>onStatus()</code>每次调用都采用两个参数：</p><ul><li><code>aPredicate</code>确定错误状态代码是否与条件匹配</li><li><code>aFunction</code>用于返回Mono，即要传播到订阅者的错误信息。</li></ul><p>如果状态代码与条件匹配，Mono则会发出相应的状态代码，并且Mono链会因错误而终止。在此示例中，Mono将发出一条 <code>RuntimeException</code>错误消息，指示该错误是客户端错误还是服务器错误。</p><h5 id="根据错误状态采取行动">根据错误状态采取行动：</h5><p>要根据Mono的<code>subscribe()</code>方法中的错误采取操作，可以在<code>subscribe</code>函数中处理响应的lambda表达式之后添加另一个lambda表达。如果在处理<code>Monumber</code>的过程中出现错误，则执行第二个lambda表达式。</p><p>下面是如何使用<code>makePostRequestAsync</code>函数和处理<code>subscribe</code>方法中的错误的更新示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">makePostRequestAsync(<span class="string">"https://example.com/api"</span>, <span class="string">"param1=value1&amp;param2=value2"</span>)</span><br><span class="line">.subscribe(response -&gt; {</span><br><span class="line">    <span class="comment">// handle the response</span></span><br><span class="line">    System.out.println(response);</span><br><span class="line">}, error -&gt; {</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">    System.err.println(<span class="string">"An error occurred: "</span> + error.getMessage());</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> WebClientResponseException) {</span><br><span class="line">        <span class="type">WebClientResponseException</span> <span class="variable">webClientResponseException</span> <span class="operator">=</span> (WebClientResponseException) error;</span><br><span class="line">        <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> webClientResponseException.getStatusCode().value();</span><br><span class="line">        <span class="type">String</span> <span class="variable">statusText</span> <span class="operator">=</span> webClientResponseException.getStatusText();</span><br><span class="line">        System.err.println(<span class="string">"Error status code: "</span> + statusCode);</span><br><span class="line">        System.err.println(<span class="string">"Error status text: "</span> + statusText);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></table></figure><p><code>subscribe</code>方法中的第二个lambda表达式检查错误是否是<code>WebClientResponseException</code>的实例，这是<code>WebClient</code>在服务器有错误响应时抛出的特定类型的异常。如果它是<code>WebClientResponseException</code>的实例，则代码将从异常中提取状态代码和状态文本，并将它们记录到日志中。</p><p>还可以根据发生的特定错误在此lambda表达式中添加其他错误处理逻辑。例如，你可以重试请求、回退到默认值或以特定方式记录错误。</p><h5 id="处理成功响应和错误的完整代码">处理成功响应和错误的完整代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">responseMono.subscribe(</span><br><span class="line">response -&gt; {</span><br><span class="line">  <span class="comment">// handle the response</span></span><br><span class="line">  LOG.info(<span class="string">"SUCCESS API Response {}"</span>, response);</span><br><span class="line">},</span><br><span class="line">error -&gt; {</span><br><span class="line">  <span class="comment">// handle the error</span></span><br><span class="line">  LOG.error(<span class="string">"An error occurred: {}"</span>, error.getMessage());</span><br><span class="line">  LOG.error(<span class="string">"error class: {}"</span>, error.getClass());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Errors / Exceptions from Server</span></span><br><span class="line">  <span class="keyword">if</span> (error <span class="keyword">instanceof</span> WebClientResponseException) {</span><br><span class="line">    <span class="type">WebClientResponseException</span> <span class="variable">webClientResponseException</span> <span class="operator">=</span></span><br><span class="line">        (WebClientResponseException) error;</span><br><span class="line">    <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> webClientResponseException.getStatusCode().value();</span><br><span class="line">    <span class="type">String</span> <span class="variable">statusText</span> <span class="operator">=</span> webClientResponseException.getStatusText();</span><br><span class="line">    LOG.info(<span class="string">"Error status code: {}"</span>, statusCode);</span><br><span class="line">    LOG.info(<span class="string">"Error status text: {}"</span>, statusText);</span><br><span class="line">    <span class="keyword">if</span> (statusCode &gt;= <span class="number">400</span> &amp;&amp; statusCode &lt; <span class="number">500</span>) {</span><br><span class="line">      LOG.info(<span class="string">"Error Response body {}"</span>, webClientResponseException.getResponseBodyAsString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> webClientResponseException.getCause();</span><br><span class="line">    LOG.error(<span class="string">"webClientResponseException"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != cause) {</span><br><span class="line">      LOG.info(<span class="string">"Cause {}"</span>, cause.getClass());</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> ReadTimeoutException) {</span><br><span class="line">        LOG.error(<span class="string">"ReadTimeout Exception"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> TimeoutException) {</span><br><span class="line">        LOG.error(<span class="string">"Timeout Exception"</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Client errors i.e. Timeouts etc - </span></span><br><span class="line">  <span class="keyword">if</span> (error <span class="keyword">instanceof</span> WebClientRequestException) {</span><br><span class="line">    LOG.error(<span class="string">"webClientRequestException"</span>);</span><br><span class="line">    <span class="type">WebClientRequestException</span> <span class="variable">webClientRequestException</span> <span class="operator">=</span> (WebClientRequestException) error;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> webClientRequestException.getCause();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != cause) {</span><br><span class="line">      LOG.info(<span class="string">"Cause {}"</span>, cause.getClass());</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> ReadTimeoutException) {</span><br><span class="line">        LOG.error(<span class="string">"ReadTimeout Exception"</span>);</span><br><span class="line">      }</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> ConnectTimeoutException) {</span><br><span class="line">        LOG.error(<span class="string">"Connect Timeout Exception"</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></table></figure><h5 id="超时">超时</h5><p>我们可以在每个请求中设置超时，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> webClient</span><br><span class="line">    .method(<span class="built_in">this</span>.httpMethod)</span><br><span class="line">    .uri(<span class="built_in">this</span>.uri)</span><br><span class="line">    .headers(httpHeaders -&gt; httpHeaders.addAll(additionalHeaders))</span><br><span class="line">    .bodyValue(<span class="built_in">this</span>.requestEntity)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(responseType)</span><br><span class="line">    .timeout(Duration.ofMillis(readTimeout))  <span class="comment">// request timeout for this request</span></span><br><span class="line">    .block();</span><br></pre></td></tr></table></figure><p>但是，我们无法在每个请求中设置连接超时，这是WebClient的属性，只能设置一次。如果需要，我们始终可以使用新的连接超时值创建一个新的Web 客户端实例。</p><p>另外连接超时、读取超时和请求超时的区别如下：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/640" alt="图片"></p><h5 id="结论">结论</h5><p>由于 RestTemplace 已弃用，开发人员应开始使用 WebClient 进行 REST调用，非阻塞 I/O调用肯定会提高应用程序性能。它不仅提供了许多其他令人兴奋的功能，例如改进的错误处理和对流的支持，而且如果需要，它还可以在阻塞模式下使用来模拟RestTemplate 行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么使用webclient&quot;&gt;为什么使用WebClient&lt;/h1&gt;
&lt;p&gt;在 &lt;strong&gt;Spring Framework 5.0
及更高版本&lt;/strong&gt;中，&lt;strong&gt;RestTemplate
已被标记废弃&lt;/strong&gt;，取而代之的是较新的</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Java" scheme="https://www.junpengzhou.top/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.junpengzhou.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列-CMS垃圾回收详解</title>
    <link href="https://www.junpengzhou.top/article/af15a4c5.html"/>
    <id>https://www.junpengzhou.top/article/af15a4c5.html</id>
    <published>2024-12-06T09:07:10.000Z</published>
    <updated>2024-12-06T09:06:46.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM系列-ZGC垃圾回收详解</title>
    <link href="https://www.junpengzhou.top/article/1a8ea7f5.html"/>
    <id>https://www.junpengzhou.top/article/1a8ea7f5.html</id>
    <published>2024-12-06T09:06:46.000Z</published>
    <updated>2024-12-06T09:06:46.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM系列-G1垃圾回收</title>
    <link href="https://www.junpengzhou.top/article/69762356.html"/>
    <id>https://www.junpengzhou.top/article/69762356.html</id>
    <published>2024-12-06T09:06:22.000Z</published>
    <updated>2024-12-06T09:06:46.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM系列-Java内存模型详解</title>
    <link href="https://www.junpengzhou.top/article/5ecbd257.html"/>
    <id>https://www.junpengzhou.top/article/5ecbd257.html</id>
    <published>2024-12-06T09:04:51.000Z</published>
    <updated>2024-12-06T09:06:46.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM系列-字节码增强技术</title>
    <link href="https://www.junpengzhou.top/article/b890c93d.html"/>
    <id>https://www.junpengzhou.top/article/b890c93d.html</id>
    <published>2024-12-06T08:59:20.000Z</published>
    <updated>2024-12-06T08:59:20.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM系列-JVM类加载机制</title>
    <link href="https://www.junpengzhou.top/article/ee36a0f3.html"/>
    <id>https://www.junpengzhou.top/article/ee36a0f3.html</id>
    <published>2024-12-06T08:58:39.000Z</published>
    <updated>2024-12-06T09:06:46.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM系列-JVM内存结构</title>
    <link href="https://www.junpengzhou.top/article/135490ad.html"/>
    <id>https://www.junpengzhou.top/article/135490ad.html</id>
    <published>2024-12-06T08:58:18.000Z</published>
    <updated>2024-12-06T09:06:46.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM系列-Java垃圾回收基础知识</title>
    <link href="https://www.junpengzhou.top/article/7bed74c2.html"/>
    <id>https://www.junpengzhou.top/article/7bed74c2.html</id>
    <published>2024-12-06T08:56:24.000Z</published>
    <updated>2024-12-06T09:06:46.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis与Mysql的数据同步</title>
    <link href="https://www.junpengzhou.top/article/4e422229.html"/>
    <id>https://www.junpengzhou.top/article/4e422229.html</id>
    <published>2024-11-14T09:02:14.000Z</published>
    <updated>2024-11-14T09:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 和 MySQL一致性问题是企业级应用中常见的挑战之一，特别是在高并发、高可用的场景下。由于Redis 是内存型数据库，具备极高的读写速度，而 MySQL作为持久化数据库，通常用于数据的可靠存储，如何保证两者数据的一致性需要具体业务场景的设计与优化。</p><p>下面我们将结合几个典型的业务场景，逐步分析如何在不同的场景下保证Redis 和 MySQL 之间的数据一致性。</p><h3 id="1-缓存更新策略cache-aside-pattern旁路缓存模式">1.<strong>缓存更新策略：Cache Aside Pattern（旁路缓存模式）</strong></h3><h4 id="场景">场景：</h4><p>在大部分业务系统中，Redis 作为缓存层用于提升系统的读取性能，而 MySQL作为持久化存储，用于保证数据的可靠性。最常见的场景是：</p><ul><li>系统先查询 Redis 缓存，如果缓存中没有数据，再从 MySQL中查询并将数据写入 Redis 缓存。</li><li>更新数据时，更新 MySQL 并删除 Redis缓存，使缓存数据失效，保证下次读取时能拿到最新数据。</li></ul><h4 id="典型业务场景">典型业务场景：</h4><ul><li><strong>商品详情页面</strong>：当用户请求某个商品详情时，首先查询Redis 缓存，如果缓存中没有，则查询 MySQL，将查询结果缓存到 Redis中；如果商品信息发生变更时，更新 MySQL 并删除 Redis 中的缓存。</li></ul><h4 id="方案分析">方案分析：</h4><ul><li><strong>读取路径</strong>：从 Redis获取缓存，如果缓存命中则直接返回数据；如果缓存未命中，则查询MySQL，将结果写入 Redis，并返回数据。</li><li><strong>写入路径</strong>：更新时先操作 MySQL，然后删除 Redis缓存中的数据。下次读取时，由于缓存未命中，会重新从 MySQL中获取最新数据。</li></ul><h4 id="如何保障一致性">如何保障一致性：</h4><ul><li><p><strong>缓存淘汰策略</strong>：MySQL 数据更新后立即删除 Redis缓存，确保下次读取时能获取到最新数据。即通过 “删除缓存”的方式避免脏数据存在于缓存中。</p></li><li><p><strong>并发问题</strong>：当并发请求较高时，可能会出现“缓存雪崩”或“缓存击穿”问题。例如：A更新 MySQL 数据，B 在缓存失效的瞬间读取了旧数据，再次缓存到Redis。为解决此问题，可以采用 <strong>延迟双删策略</strong>：</p><ol type="1"><li>删除 Redis 缓存。</li><li>更新 MySQL。</li><li>适当延迟（如 500ms），再次删除 Redis缓存，确保在并发情况下不存在缓存不一致问题。</li></ol></li><li><p><strong>业务实例：</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateProduct</span><span class="params">(Product product)</span> {</span><br><span class="line">updateProductInMySQL(product);</span><br><span class="line">deleteProductCache(product.getId());</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">}</span><br><span class="line">deleteProductCache(product.getId());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="2-先更新缓存再更新数据库">2.<strong>先更新缓存再更新数据库</strong></h3><h4 id="场景-1">场景：</h4><p>在某些实时性要求较高的场景中，可以考虑先更新 Redis缓存，然后再异步更新 MySQL 数据库。</p><h4 id="典型业务场景-1">典型业务场景：</h4><ul><li><strong>秒杀系统</strong>：例如商品库存的扣减，用户购买商品时，首先更新Redis 中的库存数量，保证极低延迟的实时性体验。然后将变更异步写入MySQL，确保持久化存储的一致性。</li></ul><h4 id="方案分析-1">方案分析：</h4><ul><li><strong>读取路径</strong>：读取 Redis缓存的库存信息，能够提供快速的读取响应。</li><li><strong>写入路径</strong>：更新 Redis中的库存数量后，使用消息队列或其他异步机制将更新同步到 MySQL。</li></ul><h4 id="如何保障一致性-1">如何保障一致性：</h4><ul><li><strong>数据最终一致性</strong>：Redis 作为前端实时数据的缓存，MySQL作为后端数据的持久化存储，采用异步更新策略时，一致性无法保证是<strong>强一致性</strong>，但可以通过使用<strong>消息队列</strong>等手段来保证<strong>最终一致性</strong>。异步写入MySQL 时，如果操作失败，可以通过重试机制或补偿机制恢复一致性。</li><li><strong>业务实例：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扣减库存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceStock</span><span class="params">(Long productId, <span class="type">int</span> amount)</span> {</span><br><span class="line">redisTemplate.decrement(<span class="string">"stock:"</span> + productId, amount);</span><br><span class="line">sendUpdateStockMessage(productId, amount);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新库存Mysql</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = "stock_update_queue")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStockInMySQL</span><span class="params">(UpdateStockMessage msg)</span> {</span><br><span class="line">    productRepository.reduceStock(msg.getProductId(), msg.getAmount());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="一致性保证策略">一致性保证策略：</h4><ul><li><strong>幂等性保障</strong>：确保消息的处理是幂等的，即相同的消息即使被处理多次，也不会导致库存重复扣减。</li><li><strong>消息重试机制</strong>：如果消费消息时更新 MySQL失败，可以设置重试机制或消息补偿机制，保证最终数据一致性。</li></ul><h3 id="3-双写操作缓存与数据库同时更新">3.<strong>双写操作（缓存与数据库同时更新）</strong></h3><h4 id="场景-2">场景：</h4><p>有时业务需要同时更新 Redis 和 MySQL的数据，如用户余额更新、积分奖励系统等场景中，Redis 和 MySQL需要同步写入。</p><h4 id="典型业务场景-2">典型业务场景：</h4><ul><li><strong>积分系统</strong>：用户消费时增加或减少积分，需要同时更新Redis 和 MySQL 中的积分记录。</li></ul><h4 id="方案分析-2">方案分析：</h4><ul><li><strong>同步写入</strong>：当更新用户积分时，Redis 和 MySQL同时更新数据。由于需要保证两个存储的同步性，必须考虑事务性问题。</li><li><strong>分布式事务</strong>：如果系统架构分布式，可能需要使用分布式事务（如<code>2PC</code>，或者更轻量的解决方案如<code>TCC</code>）来确保一致性。</li></ul><h4 id="如何保障一致性-2">如何保障一致性：</h4><ul><li><p><strong>双写一致性问题</strong>：如果同时写 Redis 和MySQL，可能会面临一致性问题。常见解决方案是通过<strong>事务补偿机制</strong>来实现。具体步骤：</p><ol type="1"><li>使用数据库事务保证 MySQL 写入成功。</li><li>如果 Redis写入失败，可以尝试重试，或在事务结束后通过补偿机制将失败的数据写入Redis。</li></ol></li><li><p><strong>业务实例：</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserPoints</span><span class="params">(Long userId, <span class="type">int</span> points)</span> {</span><br><span class="line">userRepository.updatePoints(userId, points);</span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"user:points:"</span> + userId, points);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="事务性保障">事务性保障：</h4><ul><li><strong>本地事务</strong>：在单体系统中，可以依赖数据库事务和 Redis的操作保证一致性。如果操作失败，通过重试机制来恢复一致性。</li><li><strong>分布式事务</strong>：在微服务架构中，双写操作涉及分布式事务，可能需要使用<code>TCC</code>（Try, Confirm,Cancel）等模式，或使用消息队列进行最终一致性补偿。</li></ul><hr><h3 id="4-数据回写write-back策略">4. <strong>数据回写（WriteBack）策略</strong></h3><h4 id="场景-3">场景：</h4><p>数据回写模式适用于 Redis 作为缓存层，MySQL 作为持久化存储层，但 Redis中数据修改后并不立即同步更新 MySQL，而是在特定时机触发数据回写。</p><h4 id="典型业务场景-3">典型业务场景：</h4><ul><li><strong>广告计费系统</strong>：广告点击量保存在 Redis中，以减少频繁的数据库写入压力，定期将 Redis 中的统计数据批量写入MySQL。</li></ul><h4 id="方案分析-3">方案分析：</h4><ul><li><strong>延迟回写</strong>：可以通过定时任务或者触发器将 Redis中的数据定期回写到 MySQL，这样既减少了 MySQL的压力，又保证了数据一致性。</li></ul><h4 id="如何保障一致性-3">如何保障一致性：</h4><ul><li><strong>持久化与批量同步</strong>：通过 Redis 的持久化机制（如RDB、AOF），在 Redis崩溃时不会丢失数据。通过定时器或事件驱动系统触发批量同步 MySQL。</li></ul><hr><h3 id="总结">总结</h3><p>Redis 和 MySQL的一致性保障在不同的业务场景中需要结合场景特性来进行权衡，主要的策略包括：</p><ol type="1"><li><strong>Cache AsidePattern（旁路缓存模式）</strong>：常用于读多写少的场景，写操作时删除缓存。</li><li><strong>异步更新（Write Behind）</strong>：先更新缓存再异步写入MySQL，保证最终一致性。</li><li><strong>双写策略</strong>：同时更新 Redis 和MySQL，配合事务机制确保一致性。</li><li><strong>延迟回写</strong>：通过定时批量写入 MySQL减少频繁数据库操作。</li></ol><p>每种策略有不同的适用场景，设计时需要考虑一致性、性能和可用性之间的平衡。这算得上是全网最全最详细的，货真价实的同步方案分析了，完全结合真实业务场景来考虑设计。所谓赠人玫瑰，手留余香，希望对你有帮助作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 和 MySQL
一致性问题是企业级应用中常见的挑战之一，特别是在高并发、高可用的场景下。由于
Redis 是内存型数据库，具备极高的读写速度，而 MySQL
作为持久化数据库，通常用于数据的可靠存储，如何保证两者数据的一致性需要具体业务场景的设计与优化。&lt;/p&gt;</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="中间件" scheme="https://www.junpengzhou.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JAVA21新特性-虚拟线程的使用</title>
    <link href="https://www.junpengzhou.top/article/6cdabc61.html"/>
    <id>https://www.junpengzhou.top/article/6cdabc61.html</id>
    <published>2024-09-03T06:09:55.000Z</published>
    <updated>2024-09-03T06:09:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟线程是 Java 21引入的一个新特性，用于简化并发编程。它与传统的操作系统线程相比，具有显著的优势：</p><ol type="1"><li><strong>轻量级</strong>：虚拟线程由 JVM管理，而非操作系统，因此它们的内存占用和创建成本远低于传统线程。理论上，你可以轻松创建数十万甚至更多的虚拟线程。</li><li><strong>高并发性</strong>：虚拟线程能处理更高并发的场景，特别是 I/O密集型的应用，适合开发高并发、响应式的应用程序。</li><li><strong>自动管理</strong>：无需手动管理线程池，JVM会根据负载自动调整虚拟线程的调度，简化了并发编程的复杂性。</li></ol><h1 id="虚拟线程的基础用法">虚拟线程的基础用法</h1><p>创建虚拟线程非常简单。你可以像创建传统线程一样启动虚拟线程，但它的创建与启动更加轻量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">virtualThread</span> <span class="operator">=</span> Thread.ofVirtual().start(() -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"虚拟线程正在运行"</span>);</span><br><span class="line">});</span><br><span class="line">System.out.println(<span class="string">"主线程正在运行"</span>);</span><br></pre></td></tr></table></figure><p>虚拟线程的延时启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟线程定义，是用unstarted来定义线程的核心事务，但不直接启动</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">virtualThread</span> <span class="operator">=</span> Thread.ofVirtual()</span><br><span class="line">    .name(<span class="string">"虚拟线程1"</span>)</span><br><span class="line">    .unstarted(() -&gt; System.out.println(<span class="string">"虚拟线程运行中"</span>));</span><br><span class="line"><span class="comment">// 虚拟线程正式启动</span></span><br><span class="line">virtualThread.start();</span><br><span class="line"><span class="comment">// 等待虚拟线程完成事务</span></span><br><span class="line">virtualThread.join();</span><br></pre></td></tr></table></figure><h1 id="在springboot中使用虚拟线程">在Springboot中使用虚拟线程</h1><ol type="1"><li><strong>确保 Java 版本为 21 或以上</strong>。</li><li>在 <code>pom.xml</code> 中启用<code>--enable-preview</code>，以便支持虚拟线程特性。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>21<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>21<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span>&gt;</span>--enable-preview<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>在 <code>application.properties</code> 中启用性能监控工具</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">health,info,metrics</span></span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>在 Spring Boot 中为 Tomcat 配置虚拟线程执行器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TomcatProtocolHandlerCustomizer&lt;?&gt; protocolHandlerVirtualThreadExecutorCustomizer() {</span><br><span class="line">    <span class="keyword">return</span> protocolHandler -&gt; protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>虚拟线程的创建与执行切换效率快，相对应的在虚拟线程中创建http请求进行对比会发现吞吐量大幅提升，响应时间显著缩短。</p><h1 id="java性能提升的其他技巧">Java性能提升的其他技巧</h1><p>除了虚拟线程，Java 还有一些其他的性能提升技巧，尤其适用于 Spring Boot高并发场景：</p><ol type="1"><li><p><strong>使用并行流</strong>：对于 CPU密集型任务，可以使用并行流（<code>parallelStream()</code>）来利用多核CPU，提高处理速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">numbers.parallelStream().forEach(number -&gt; {</span><br><span class="line">    System.out.println(number * <span class="number">2</span>);</span><br><span class="line">});</span><br></pre></td></tr></table></figure></li><li><p><strong>异步编程与CompletableFuture</strong>：对于 I/O密集型任务，可以使用 <code>CompletableFuture</code>进行异步处理，减少线程阻塞，提高响应性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">    <span class="comment">// 异步执行任务</span></span><br><span class="line">    System.out.println(<span class="string">"异步任务完成"</span>);</span><br><span class="line">});</span><br><span class="line">future.join();  <span class="comment">// 等待任务完成</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化数据库查询</strong>：减少数据库查询的次数，使用缓存（如Redis）来存储频繁查询的数据，减少不必要的 I/O 操作。</p></li><li><p><strong>内存管理优化</strong>：通过使用对象池（如<code>Apache Commons Pool</code>）来管理资源，减少频繁的对象创建和销毁，提高内存使用效率。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚拟线程是 Java 21
引入的一个新特性，用于简化并发编程。它与传统的操作系统线程相比，具有显著的优势：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;轻量级&lt;/strong&gt;：虚拟线程由 JVM
管理，而非操作系统，因此它们的内存占用和创建成本远低于传统</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Java" scheme="https://www.junpengzhou.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC容器源码分析</title>
    <link href="https://www.junpengzhou.top/article/fbb9694d.html"/>
    <id>https://www.junpengzhou.top/article/fbb9694d.html</id>
    <published>2024-08-14T03:52:18.000Z</published>
    <updated>2024-08-14T03:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p><p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p><p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p><p>希望通过本文可以让读者不惧怕阅读 Spring源码，也希望大家能反馈表述错误或不合理的地方。</p><h2 id="引言">引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"classpath:applicationfile.xml"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven的小伙伴直接在 dependencies中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring的所有相关的东西都加进来的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.3</span><span class="number">.11</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>spring-context 会自动将spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar包带进来。</p></blockquote><p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring其实不是很了解，Spring是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p><p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了ClassPathXmlApplicationContext 以外，我们也还有其他构建ApplicationContext的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/1.png" alt="1"></p><blockquote><p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为Spring为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p><p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p></blockquote><p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到ApplicationContext 接口，同样的，我们也可以使用绿颜色的<strong>FileSystemXmlApplicationContext</strong> 和<strong>AnnotationConfigApplicationContext</strong> 这两个类。</p><p><strong>1、FileSystemXmlApplicationContext</strong>的构造函数需要一个 xml 配置文件在系统中的路径，其他和ClassPathXmlApplicationContext 基本上一样。</p><p><strong>2、AnnotationConfigApplicationContext</strong>是基于注解来使用的，它不需要配置文件，采用 java配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p><p>不过本文旨在帮助大家理解整个构建流程，所以决定使用ClassPathXmlApplicationContext 进行分析。</p><p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p><p>首先，定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> {</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>定义接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>接下来，我们在 <strong>resources</strong>目录新建一个配置文件，文件名随意，通常叫 application.xml 或application-xxx.xml 就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以跑起来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"classpath:application.xml"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"context 启动成功"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> context.getBean(MessageService.class);</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个Bean 中注入依赖等。</p><h2 id="beanfactory-简介">BeanFactory 简介</h2><p>BeanFactory，从名字上也很好理解，生产 bean的工厂，它负责生产和管理各个 bean 实例。</p><p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory接口相关的主要的继承结构：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/2.png" alt="2"></p><p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p><ol type="1"><li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable的意思就是，通过这个接口，我们可以获取多个Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean的。</li><li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical单词本身已经能说明问题了，也就是说我们可以在应用中起多个BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li><li>AutowireCapableBeanFactory 这个名字中的 Autowire大家都非常熟悉，它就是用来自动装配 Bean用的，但是仔细看上图，ApplicationContext并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到ApplicationContext 接口定义中的最后一个方法getAutowireCapableBeanFactory() 就知道了。</li><li>ConfigurableListableBeanFactory也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而ApplicationContext 没有。这点之后会用到。</li><li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li></ol><p>然后，请读者打开编辑器，翻一下BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p><h2 id="启动过程分析">启动过程分析</h2><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p><p>第一步，我们肯定要从 ClassPathXmlApplicationContext的构造方法说起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> {</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> {</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException {</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) {</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh()会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p><p>往下看，refresh()方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) {</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> {</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>下面，我们开始一步步来肢解这个 refresh() 方法。</p><h3 id="创建-bean-容器前的准备工作">创建 Bean 容器前的准备工作</h3><p>这个比较简单，直接看代码中的几个注释即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> {</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">      logger.info(<span class="string">"Refreshing "</span> + <span class="built_in">this</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ApplicationEvent&gt;();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="创建-bean-容器加载并注册-bean">创建 Bean 容器，加载并注册Bean</h3><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p><p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化BeanFactory、加载 Bean、注册 Bean 等等。</p><p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean实例并未在这一步生成。</p><p>// AbstractApplicationContext.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> {</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext.java 120</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span></span><br><span class="line">   <span class="comment">// ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) {</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 下面这两个方法很重要，别跟丢了，具体细节之后说</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) {</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为BeanFactory 的实现类，而是说其内部持有一个实例化的BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory相关的操作其实是委托给这个实例来处理的。</p></blockquote><p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong>？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了BeanFactory下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/3.png" alt="3"></p><p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory还通过实现右边的 AbstractAutowireCapableBeanFactory通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory基本上是最牛的 BeanFactory了，这也是为什么这边会使用这个类来实例化的原因。</p><blockquote><p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p><p>之前我们说过 ApplicationContext 接口能获取到AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到DefaultListableBeanFactory 了。</p><p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过Spring。</p></blockquote><p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p><p>这里的 BeanDefinition 就是我们所说的 Spring 的Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于Spring 的 BeanFactory 中。</p><p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean在代码层面上可以简单认为是 BeanDefinition 的实例。</p><blockquote><p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean等等。</p></blockquote><h4 id="beandefinition-接口定义">BeanDefinition 接口定义</h4><p>我们来看下 BeanDefinition 的接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement {</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on="" 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>这个 BeanDefinition其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p><p>这里接口虽然那么多，但是没有类似 getInstance()这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p></blockquote><p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory()方法中的剩余部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure><p>虽然只有两个方法，但路还很长啊。。。</p><h4 id="customizebeanfactory">customizeBeanFactory</h4><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许BeanDefinition 覆盖、是否允许循环引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> {</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖</span></span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>BeanDefinition的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding属性为null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而C 依赖 A。</p><p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖B，在 B 的构造方法中依赖 A 是不行的。</p><p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p><p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p><h4 id="加载-bean-loadbeandefinitions">加载 Bean:loadBeanDefinitions</h4><p>接下来是最重要的 loadBeanDefinitions(beanFactory)方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p><p>读取配置的操作在 XmlBeanDefinitionReader中，其负责加载配置、解析。</p><p>// AbstractXmlApplicationContext.java 80</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException {</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">   <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line">   <span class="comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 重点来了，继续往下</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p><p>// AbstractXmlApplicationContext.java 120</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException {</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 往下看</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   }</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line">   Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span></span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) {</span><br><span class="line">      <span class="comment">// 继续往下看</span></span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span></span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 303</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 314</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">      logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 用一个 ThreadLocal 来存放配置文件资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) {</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) {</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">// 核心部分是这里，往下面看</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">finally</span> {</span><br><span class="line">         inputStream.close();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">finally</span> {</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) {</span><br><span class="line">         <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还在这个文件中，第 388 行</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 继续</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 还在这个文件中，第 505 行</span></span><br><span class="line"><span class="comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line">   <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 这里</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 90</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> {</span><br><span class="line">   <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">   <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">   <span class="comment">// 从 xml 根节点开始解析文件</span></span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">}         </span><br></pre></td></tr></table></figure><p>经过漫长的链路，一个配置文件终于转换为一颗 DOM树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个for 循环的。下面开始从根节点开始解析：</p><h5 id="doregisterbeandefinitions">doRegisterBeanDefinitions：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 116</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> {</span><br><span class="line">   <span class="comment">// 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span></span><br><span class="line">   <span class="comment">// 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span></span><br><span class="line">   <span class="comment">// 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span></span><br><span class="line">   <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">   <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) {</span><br><span class="line">      <span class="comment">// 这块说的是根节点 &lt;beans ... profile="dev" /&gt; 中的 profile 是否是当前环境需要的，</span></span><br><span class="line">      <span class="comment">// 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析</span></span><br><span class="line">      <span class="comment">// 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) {</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">               logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                     <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   preProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line">   <span class="comment">// 往下看</span></span><br><span class="line">   parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">   postProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>preProcessXml(root) 和 postProcessXml(root)是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p><p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile做了简单的解释，读者可以参考一下。</p><p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="comment">// 其他的属于 custom 的</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> {</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) {</span><br><span class="line">      <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">         <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) {</span><br><span class="line">            <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) {</span><br><span class="line">               <span class="comment">// 解析 default namespace 下面的几个元素</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele);这两个分支了。</p><p>parseDefaultElement(ele, delegate) 代表解析的节点是<code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code>这几个。</p><blockquote><p>这里的四个标签之所以是 <strong>default</strong>的，是因为它们是处于这个 namespace 下定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/beans</span><br></pre></td></tr></table></figure><p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">          http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而对于其他的标签，将进入到 delegate.parseCustomElement(element)这个分支。如我们经常会使用到的<code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p><p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml头部的地方也要引入相应的 namespace 和 .xsd文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler等。</p><p>假如读者想分析<code>&lt;context:property-placeholder location="classpath:xx.properties" /&gt;</code>的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/mvc   </span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">       "</span></span></span><br><span class="line"><span class="tag">      <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code>这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler这个处理类。</p></blockquote><p>回过神来，看看处理 default 标签的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> {</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签定义</span></span><br><span class="line">      <span class="comment">// &lt;alias name="fromName" alias="toName"/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {</span><br><span class="line">      <span class="comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点<code>&lt;bean /&gt;</code> 标签出来说。</p><h5 id="processbeandefinition-解析-bean-标签">processBeanDefinition 解析bean 标签</h5><p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code>标签：</p><p>// DefaultBeanDefinitionDocumentReader 298</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> {</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span></span><br><span class="line">   <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) {</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) {</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>继续往下看怎么解析之前，我们先看下<strong><code>&lt;bean /&gt;</code></strong>标签中可以定义哪些属性：</p><table><thead><tr class="header"><th>Property</th><th></th></tr></thead><tbody><tr class="odd"><td>class</td><td>类的全限定名</td></tr><tr class="even"><td>name</td><td>可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr class="odd"><td>scope</td><td>作用域</td></tr><tr class="even"><td>constructor arguments</td><td>指定构造参数</td></tr><tr class="odd"><td>properties</td><td>设置属性的值</td></tr><tr class="even"><td>autowiring mode</td><td>no(默认值)、byName、byType、 constructor</td></tr><tr class="odd"><td>lazy-initialization mode</td><td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr class="even"><td>initialization method</td><td>bean 属性设置完成后，会调用这个方法</td></tr><tr class="odd"><td>destruction method</td><td>bean 销毁后的回调方法</td></tr></tbody></table><p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解Spring 的配置了。</p><p>简单地说就是像下面这样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">name</span>=<span class="string">"name1, name2, name3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.ExampleBean"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- property 的几种情况 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，除了上面举例出来的这些，还有factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code>这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean的了解程度。</p><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>// BeanDefinitionParserDelegate 428</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> {</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="literal">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> {</span><br><span class="line">   <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   <span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">   <span class="comment">// 当然，如果你不定义 name 属性的话，就是空的了</span></span><br><span class="line">   <span class="comment">// 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) {</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">   <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">         logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="literal">null</span>) {</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">   <span class="comment">// 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span></span><br><span class="line">   <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">      <span class="comment">// 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) {</span><br><span class="line">         <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) {<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">// 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span></span><br><span class="line">               <span class="comment">//   1. beanName 为：com.javadoop.example.MessageServiceImpl#0</span></span><br><span class="line">               <span class="comment">//   2. beanClassName 为：com.javadoop.example.MessageServiceImpl</span></span><br><span class="line"></span><br><span class="line">               beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"></span><br><span class="line">               <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {</span><br><span class="line">                  <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">               logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">      Element ele, String beanName, BeanDefinition containingBean)</span> {</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) {</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) {</span><br><span class="line">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">      <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">      error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) {</span><br><span class="line">      error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">      error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">finally</span> {</span><br><span class="line">      <span class="built_in">this</span>.parseState.pop();</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> {</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">   <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) {</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个<code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title class_">BeanMetadataElement</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后我们准备注册这个BeanDefinition，最后，把这个注册事件发送出去。</p><p>下面，我们开始说说注册 Bean 吧。</p><h5 id="注册-bean">注册 Bean</h5><p>// BeanDefinitionReaderUtils 143</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 注册这个 Bean</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) {</span><br><span class="line">         <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">         <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>// DefaultListableBeanFactory 793</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(...);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span></span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">   oldBeanDefinition = <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) {</span><br><span class="line">         <span class="comment">// 如果不允许覆盖的话，抛异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription()...</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {</span><br><span class="line">         <span class="comment">// log...用框架定义的 Bean 覆盖用户自定义的 Bean </span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) {</span><br><span class="line">         <span class="comment">// log...用新的 Bean 覆盖旧的 Bean</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">      <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">      <span class="comment">// 注意，"注册Bean" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">      <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) {</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) {</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.manualSingletonNames.contains(beanName)) {</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(<span class="built_in">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="built_in">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">         <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">         <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">         <span class="comment">//     registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">         <span class="comment">// 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面"手动"注册一些 Bean，</span></span><br><span class="line">         <span class="comment">// 如 "environment"、"systemProperties" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">         <span class="built_in">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它。</span></span><br><span class="line">      <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span> || containsSingleton(beanName)) {</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code>配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition到注册中心，并且发送了注册事件。</p><p>--------- 分割线 ---------</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h3 id="bean-容器实例化完成后">Bean 容器实例化完成后</h3><p>说到这里，我们回到 refresh()方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完obtainFreshBeanFactory() 方法。</p><p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) {</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> {</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="准备-bean-容器-preparebeanfactory">准备 Bean 容器:prepareBeanFactory</h3><p>之前我们说过，Spring 把我们在 xml 配置的 bean都注册以后，会"手动"注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">   <span class="comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span></span><br><span class="line">   <span class="comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span></span><br><span class="line">   <span class="comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，</span></span><br><span class="line">   <span class="comment">//   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span></span><br><span class="line">   <span class="comment">// Spring 会通过其他方式来处理这些依赖。</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span></span><br><span class="line"><span class="comment">    * 之前我们说过，"当前 ApplicationContext 持有一个 BeanFactory"，这里解释了第一行。</span></span><br><span class="line"><span class="comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span></span><br><span class="line"><span class="comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span></span><br><span class="line"><span class="comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span></span><br><span class="line">   <span class="comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span></span><br><span class="line">   <span class="comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span></span><br><span class="line">   <span class="comment">//    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面几行代码我们可以知道，Spring 往往很 "智能" 就是因为它会帮我们默认注册一些有用的 bean，</span></span><br><span class="line"><span class="comment">    * 我们也可以选择覆盖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面这块代码中，Spring 对一些特殊的 bean进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p><h3 id="初始化所有的-singleton-beans">初始化所有的 singleton beans</h3><p>我们的重点当然是<code>finishBeanFactoryInitialization(beanFactory);</code>这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring会在这个阶段完成所有的 singleton beans 的实例化。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean都已经初始化并且其中的 postProcessBeanFactory(factory)方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如<code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring会在接下来初始化所有的 singleton beans。</p><p>// AbstractApplicationContext.java 834</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span></span><br><span class="line">   <span class="comment">// 什么，看代码这里没有初始化 Bean 啊！</span></span><br><span class="line">   <span class="comment">// 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) {</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StringValueResolver</span>() {</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> String <span class="title function_">resolveStringValue</span><span class="params">(String strVal)</span> {</span><br><span class="line">            <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         }</span><br><span class="line">      });</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">   <span class="comment">// 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) {</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">   <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始初始化</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory这个类了，这个类大家应该都不陌生了吧。</p><h4 id="preinstantiatesingletons">preInstantiateSingletons</h4><p>// DefaultListableBeanFactory 728</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) {</span><br><span class="line">      <span class="built_in">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="built_in">this</span>);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// this.beanDefinitionNames 保存了所有的 beanNames</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 合并父 Bean 中的配置，注意 &lt;bean id="" class="" parent="" /&gt; 中的 parent，用的不多吧，</span></span><br><span class="line">      <span class="comment">// 考虑到这可能会影响大家的理解，我在附录中解释了一下 "Bean 继承"，不了解的请到附录中看一下</span></span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {</span><br><span class="line">         <span class="comment">// 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) {</span><br><span class="line">            <span class="comment">// FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span></span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">// 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span></span><br><span class="line">            <span class="type">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) {</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() {</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                     <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  }</span><br><span class="line">               }, getAccessControlContext());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">               isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) {</span><br><span class="line"></span><br><span class="line">               getBean(beanName);</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">   <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) {</span><br><span class="line">         <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) {</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() {</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               }</span><br><span class="line">            }, getAccessControlContext());</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">else</span> {</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p><h4 id="getbean">getBean</h4><p>在继续前进之前，读者应该具备 FactoryBean的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p><p>// AbstractBeanFactory 196</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span></span><br><span class="line"><span class="comment">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException {</span><br><span class="line">   <span class="comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span></span><br><span class="line">   <span class="comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意跟着这个，这个是返回值</span></span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查下是不是已经创建过了</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span></span><br><span class="line">   <span class="comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">            logger.debug(<span class="string">"..."</span>);</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">else</span> {</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span></span><br><span class="line">      <span class="comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span></span><br><span class="line">      <span class="comment">// (FactoryBean 知识，读者若不清楚请移步附录)</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) {</span><br><span class="line">         <span class="comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span></span><br><span class="line">         <span class="comment">// 往往是因为陷入了循环引用</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) {</span><br><span class="line">         <span class="comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (args != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 返回父容器的查询结果</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) {</span><br><span class="line">         <span class="comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">         <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) {</span><br><span class="line">               <span class="comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span></span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) {</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               }</span><br><span class="line">               <span class="comment">// 注册一下依赖关系</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">// 先初始化被依赖项</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() {</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">                  <span class="keyword">try</span> {</span><br><span class="line">                     <span class="comment">// 执行创建 Bean，详情后面再说</span></span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  }</span><br><span class="line">                  <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     <span class="keyword">throw</span> ex;</span><br><span class="line">                  }</span><br><span class="line">               }</span><br><span class="line">            });</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) {</span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">// 执行创建 Bean</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">finally</span> {</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            }</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">         <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="literal">null</span>) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">               <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() {</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">// 执行创建 Bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     }</span><br><span class="line">                     <span class="keyword">finally</span> {</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     }</span><br><span class="line">                  }</span><br><span class="line">               });</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; bean != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) {</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException;</span><br></pre></td></tr></table></figure><p>第三个参数 args数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p><p>这回我们要到一个新的类了AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p><p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> userService.getMessage();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">&lt;bean id=<span class="string">"messageService"</span> class=<span class="string">"com.javadoop.example.MessageServiceImpl"</span> /&gt;</span><br></pre></td></tr></table></figure><p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring会处理这种情况。</p><p>好了，读者要知道这么回事就可以了，继续向前。</p><p>// AbstractAutowireCapableBeanFactory 447</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException {</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   }</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保 BeanDefinition 中的 Class 被加载</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) {</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span></span><br><span class="line">   <span class="comment">// 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span></span><br><span class="line">   <span class="comment">// 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">      <span class="comment">// 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) {</span><br><span class="line">         <span class="keyword">return</span> bean; </span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 重头戏，创建 bean</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">      logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> beanInstance;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="创建-bean">创建 Bean</h4><p>我们继续往里看 doCreateBean 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking {<span class="doctag">@code</span> postProcessBeforeInstantiation} callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException {</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">      instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 "bean 实例"</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">// 类型</span></span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) {</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) {</span><br><span class="line">         <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">         }</span><br><span class="line">         mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">   <span class="comment">// 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">         logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">               <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">      }</span><br><span class="line">      addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() {</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">            <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         }</span><br><span class="line">      });</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) {</span><br><span class="line">         <span class="comment">// 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span></span><br><span class="line">         <span class="comment">// 这里就是处理 bean 初始化完成后的各种回调</span></span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) {</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) {</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) {</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                     <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                     <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                     <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>到这里，我们已经分析完了 doCreateBean方法，总的来说，我们已经说完了整个初始化流程。</p><p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean实例的 createBeanInstance 方法，一个是依赖注入的 populateBean方法，还有就是回调方法 initializeBean。</p><p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p><h5 id="创建-bean-实例">创建 Bean 实例</h5><p>我们先看看 createBeanInstance方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> {</span><br><span class="line">   <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验一下这个类的访问权限</span></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>)  {</span><br><span class="line">      <span class="comment">// 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span></span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">   <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (args == <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) {</span><br><span class="line">         <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) {</span><br><span class="line">            resolved = <span class="literal">true</span>;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (resolved) {</span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) {</span><br><span class="line">         <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">         <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// 无参构造函数</span></span><br><span class="line">         <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (ctors != <span class="literal">null</span> ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {</span><br><span class="line">      <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用无参构造函数</span></span><br><span class="line">   <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> {</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) {</span><br><span class="line">         beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">            }</span><br><span class="line">         }, getAccessControlContext());</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// 实例化</span></span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 包装一下，返回</span></span><br><span class="line">      <span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="keyword">return</span> bw;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们可以看到，关键的地方在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure><p>这里会进行实际的实例化过程，我们进去看看:</p><p>// SimpleInstantiationStrategy 59</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> {</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">   <span class="comment">// 方法覆写 请参见附录"方法注入"中对 lookup-method 和 replaced-method 的介绍</span></span><br><span class="line">   <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) {</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      <span class="keyword">synchronized</span> (bd.constructorArgumentLock) {</span><br><span class="line">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         <span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface()) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) {</span><br><span class="line">                  constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Constructor&lt;?&gt;&gt;() {</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception {</span><br><span class="line">                        <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="literal">null</span>);</span><br><span class="line">                     }</span><br><span class="line">                  });</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">else</span> {</span><br><span class="line">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) <span class="literal">null</span>);</span><br><span class="line">               }</span><br><span class="line">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">      <span class="comment">// tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span></span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p><h5 id="bean-属性注入">bean 属性注入</h5><p>看完了 createBeanInstance(...) 方法，我们来看看 populateBean(...)方法，该方法负责进行属性设值，处理依赖。</p><p>// AbstractAutowireCapableBeanFactory 1203</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> {</span><br><span class="line">   <span class="comment">// bean 实例的所有属性都在这里了</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (!pvs.isEmpty()) {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span></span><br><span class="line">   <span class="comment">// InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span></span><br><span class="line">   <span class="comment">// 我也没找到有实际的使用，所以我们暂且忽略这块吧</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span></span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过类型装配。复杂一些</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) {</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) {</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">               <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">               <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span></span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == <span class="literal">null</span>) {</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               }</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) {</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="initializebean">initializeBean</h5><p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> {</span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) {</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() {</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         }</span><br><span class="line">      }, getAccessControlContext());</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">      <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>大家发现没有，BeanPostProcessor的两个回调都发生在这边，只不过中间处理了init-method，是不是和读者原来的认知有点不一样了？</p><h2 id="附录">附录</h2><h3 id="id-和-name">id 和 name</h3><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0个或多个别名（aliases）。</p><p>我们从 Spring 容器中获取 Bean 的时候，可以根据beanName，也可以通过别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.getBean(<span class="string">"beanName or alias"</span>);</span><br></pre></td></tr></table></figure><p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和name，看几个例子就知道是怎么回事了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为m1、m2、m3。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p><p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，没有别名。</p><h3 id="配置是否允许-bean-覆盖是否允许循环依赖">配置是否允许 Bean覆盖、是否允许循环依赖</h3><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为null。如果在同一配置文件中 Bean id 或 name重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p><p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而C 却依赖 A。默认 allowCircularReferences 也是 null。</p><p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p><p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href="https://jira.spring.io/browse/SPR-4374">jira</a>的讨论中说明了怎么配置这两个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoBeanOverridingContextLoader</span> <span class="keyword">extends</span> <span class="title class_">ContextLoader</span> {</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeContext</span><span class="params">(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext)</span> {</span><br><span class="line">    <span class="built_in">super</span>.customizeContext(servletContext, applicationContext);</span><br><span class="line">    <span class="type">AbstractRefreshableApplicationContext</span> <span class="variable">arac</span> <span class="operator">=</span> (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(<span class="literal">false</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyContextLoaderListener</span> <span class="keyword">extends</span> <span class="title class_">org</span>.springframework.web.context.ContextLoaderListener {</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> ContextLoader <span class="title function_">createContextLoader</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoBeanOverridingContextLoader</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><p>如果以上方式不能满足你的需求，请参考这个链接：<a href="http://blog.csdn.net/zgmzyr/article/details/39380477">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p><h3 id="profile">profile</h3><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应该不必做过多解释了吧，看每个文件第一行的 profile=""。</p><p>当然，我们也可以在一个配置文件中使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>理解起来也很简单吧。</p><p>接下来的问题是，怎么使用特定的 profile 呢？Spring在启动的过程中，会去寻找 “spring.profiles.active”的属性值，根据这个属性值来的。那怎么配置这个值呢？</p><p>Spring 会在这几个地方寻找 spring.profiles.active的属性值：操作系统环境变量、JVM 系统变量、web.xml中定义的参数、JNDI。</p><p>最简单的方式莫过于在程序启动的时候指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active="profile1,profile2"</span><br></pre></td></tr></table></figure><blockquote><p>profile 可以激活多个</p></blockquote><p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"development"</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh(); <span class="comment">// 重启</span></span><br></pre></td></tr></table></figure><p>如果是 Spring Boot 的话更简单，我们一般会创建application.properties、application-dev.properties、application-prod.properties等文件，其中 application.properties配置各个环境通用的配置，application-{profile}.properties中配置特定环境的配置，然后在启动的时候指定 profile：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring.profiles.active=prod -jar JavaDoop.jar</span><br></pre></td></tr></table></figure><p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles指定，这里就不展开了。</p><h3 id="工厂模式生成-bean">工厂模式生成 Bean</h3><p>请读者注意 factory-bean 和 FactoryBean的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍FactoryBean。</p><p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring中怎么配置这两个，来个代码示例就什么都清楚了。</p><p>静态工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"examples.ClientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></span><br><span class="line">public class ClientService {</span><br><span class="line">    private static ClientService clientService = new ClientService();</span><br><span class="line">    private ClientService() {}</span><br><span class="line"></span><br><span class="line">    // 静态方法</span><br><span class="line">    public static ClientService createInstance() {</span><br><span class="line">        return clientService;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>实例工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createAccountServiceInstance"</span>/&gt;</span></span><br><span class="line">public class DefaultServiceLocator {</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() {</span><br><span class="line">        return clientService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public AccountService createAccountServiceInstance() {</span><br><span class="line">        return accountService;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="factorybean">FactoryBean</h3><p>FactoryBean 适用于 Bean的创建过程比较复杂的场景，比如数据库连接池的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; {</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    Class&lt;T&gt; <span class="title function_">getObjectType</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> { </span><br><span class="line">    <span class="keyword">private</span> Car car ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCar</span><span class="params">(Car car)</span>{ <span class="built_in">this</span>.car = car;  }  </span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car的复杂过程包装起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCarFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Car&gt;{</span><br><span class="line">    <span class="keyword">private</span> String make; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMake</span><span class="params">(String m)</span>{ <span class="built_in">this</span>.make =m ; }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> y)</span>{ <span class="built_in">this</span>.year = y; }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getObject</span><span class="params">()</span>{ </span><br><span class="line">      <span class="comment">// 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span></span><br><span class="line">      <span class="type">CarBuilder</span> <span class="variable">cb</span> <span class="operator">=</span> CarBuilder.car();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(year!=<span class="number">0</span>) cb.setYear(<span class="built_in">this</span>.year);</span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(<span class="built_in">this</span>.make)) cb.setMake( <span class="built_in">this</span>.make ); </span><br><span class="line">      <span class="keyword">return</span> cb.factory(); </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Car&gt; <span class="title function_">getObjectType</span><span class="params">()</span> { <span class="keyword">return</span> Car.class ; } </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> { <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们看看装配的时候是怎么配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"com.javadoop.MyCarFactoryBean"</span> <span class="attr">id</span> = <span class="string">"car"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"make"</span> <span class="attr">value</span> =<span class="string">"Honda"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"year"</span> <span class="attr">value</span> =<span class="string">"1984"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"com.javadoop.Person"</span> <span class="attr">id</span> = <span class="string">"josh"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"car"</span> <span class="attr">ref</span> = <span class="string">"car"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring已经封装好了。</p><p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean依赖的越来越少了，更多时候，我们可能会采用 java config的方式来配置，这里有什么不一样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarConfiguration</span> { </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> MyCarFactoryBean <span class="title function_">carFactoryBean</span><span class="params">()</span>{ </span><br><span class="line">      <span class="type">MyCarFactoryBean</span> <span class="variable">cfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCarFactoryBean</span>();</span><br><span class="line">      cfb.setMake(<span class="string">"Honda"</span>);</span><br><span class="line">      cfb.setYear(<span class="number">1984</span>);</span><br><span class="line">      <span class="keyword">return</span> cfb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">aPerson</span><span class="params">()</span>{ </span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      <span class="comment">// 注意这里的不同</span></span><br><span class="line">    person.setCar(carFactoryBean().getObject());</span><br><span class="line">    <span class="keyword">return</span> person; </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是FactoryBean 和我们没关系。</p><h3 id="初始化-bean-的回调">初始化 Bean 的回调</h3><p>有以下四种方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br><span class="line">public class AnotherExampleBean implements InitializingBean {</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() {</span><br><span class="line">        // do some initialization work</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">@Bean(initMethod = "init")</span><br><span class="line">public Foo foo() {</span><br><span class="line">    return new Foo();</span><br><span class="line">}</span><br><span class="line">@PostConstruct</span><br><span class="line">public void init() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="销毁-bean-的回调">销毁 Bean 的回调</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></span><br><span class="line">public class AnotherExampleBean implements DisposableBean {</span><br><span class="line"></span><br><span class="line">    public void destroy() {</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">@Bean(destroyMethod = "cleanup")</span><br><span class="line">public Bar bar() {</span><br><span class="line">    return new Bar();</span><br><span class="line">}</span><br><span class="line">@PreDestroy</span><br><span class="line">public void cleanup() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="conversionservice">ConversionService</h3><p>既然文中说到了这个，顺便提一下好了。</p><p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller方法上的参数进行绑定的时候用。</p><p>像前端传过来的字符串、整数要转换为后端的 String、Integer很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用ConversionService 来进行转换。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.learning.utils.StringToEnumConverterFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ConversionService 接口很简单，所以要自定义一个 convert的话也很简单。</p><p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p><p>来看一个很简单的例子，这样比什么都管用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Date&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> DateUtils.parseDate(source, <span class="string">"yyyy-MM-dd"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, <span class="string">"yyyy-MM-dd HH:mm"</span>, <span class="string">"HH:mm:ss"</span>, <span class="string">"HH:mm"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (ParseException e) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>只要注册这个 Bean就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date类型了，不需要其他任何操作。</p><h3 id="bean-继承">Bean 继承</h3><p>在初始化 Bean 的地方，我们说过了这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure><p>这里涉及到的就是 <code>&lt;bean parent="" /&gt;</code> 中的 parent属性，我们来看看 Spring 中是用这个来干什么的。</p><p>首先，我们要明白，这里的继承和 java语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parentbean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p><p>Spring 中提供了继承自 AbstractBeanDefinition 的<code>ChildBeanDefinition</code> 来表示 child bean。</p><p>看如下一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBean"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span> class=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"inheritsWithDifferentClass"</span> class=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span><br><span class="line">        parent=<span class="string">"inheritedTestBean"</span> init-method=<span class="string">"initialize"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"override"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>parent bean 设置了 <code>abstract="true"</code>所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对name 属性进行了覆写。</p><p>child bean 会继承scope、构造器参数值、属性值、init-method、destroy-method 等等。</p><p>当然，我不是说 parent bean 中的 abstract = true在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans的时候会忽略这个 bean。</p><p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract =true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="方法注入">方法注入</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖singleton，或者 prototype 依赖 prototype都很好解决，直接设置属性依赖就可以了。</p><p>但是，如果是 singleton 依赖 prototype呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的bean。</p><p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从BeanFactory中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring项目大家都会定义那么个工具类的。</p><p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p><h4 id="lookup-method">lookup-method</h4><p>我们来看一下 Spring Reference 中提供的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no more Spring imports!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> {</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCommand"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"myCommand"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 采用 <strong>CGLIB生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 finalclass，抽象方法上也不能加 final。</p><p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置<code>&lt;lookup-method /&gt;</code> 了，其他不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> {</span><br><span class="line">        <span class="type">MyCommand</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup("myCommand")</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package="com.javadoop" /&gt;</code></p></blockquote><p>甚至，我们可以像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> {</span><br><span class="line">        <span class="type">MyCommand</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>上面的返回值用了 MyCommand，当然，如果 Command只有一个实现类，那返回值也可以写 Command。</p></blockquote><h4 id="replaced-method">replaced-method</h4><p>记住它的功能，就是替换掉 bean 中的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyValueCalculator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">computeValue</span><span class="params">(String input)</span> {</span><br><span class="line">        <span class="comment">// some real code...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>方法覆写，注意要实现 MethodReplacer 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title class_">org</span>.springframework.beans.factory.support.MethodReplacer {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>配置也很简单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>arg-type明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p></blockquote><h3 id="beanpostprocessor">BeanPostProcessor</h3><p>应该说 BeanPostProcessor 概念在 Spring中也是比较重要的。我们看下接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class="line"></span><br><span class="line">   Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">   Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行postProcessBeforeInitialization 这个方法，初始化完成之后会执行postProcessAfterInitialization这个方法。但是，这么理解是非常片面的。</p><p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的obtainFactory() 方法结束后的prepareBeanFactory(factory)，大家仔细看会发现，Spring往容器中添加了这两个BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p><p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean实例，所以，没事的话这里不能随便返回个 null。</p><p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的bean 实例做一些事情。但是对于 Spring框架来说，它会决定是不是要在这个方法中返回 bean实例的代理，这样就有更大的想象空间了。</p><p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor的话，它的执行时机是什么时候？</p><p>如果仔细看了代码分析的话，其实很容易知道了，在 bean实例化完成、属性注入完成之后，会执行回调方法，具体请参见类AbstractAutowireCapableBeanFactory#initBean 方法。</p><p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调init-method，然后再回调 BeanPostProcessor 的postProcessAfterInitialization 方法。</p><p>转载自：<a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下
Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解
Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解
Spring </summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Java" scheme="https://www.junpengzhou.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架结构与学习重点</title>
    <link href="https://www.junpengzhou.top/article/6b8e949c.html"/>
    <id>https://www.junpengzhou.top/article/6b8e949c.html</id>
    <published>2024-08-13T03:15:40.000Z</published>
    <updated>2024-08-13T03:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一spring框架学习路线图">一、Spring框架学习路线图</h1><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="spring框架学习总结思维导图"></p><h1 id="二什么是spring-">二、什么是Spring ?</h1><blockquote><p>Spring 是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java开发框架，由 Rod Johnson 在其著作 Expert One-On-One J2EE Development andDesign中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为J2EE 应用程序开发提供集成的框架。Spring 使用基本的 JavaBean来完成以前只可能由 EJB 完成的事情。</p></blockquote><p>然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。<strong>Spring的核心是控制反转（IoC）和面向切面（AOP）</strong>。简单来说，Spring是一个分层的 <code>JavaSE/EE full-stack</code>(一站式)<code>轻量级</code>开源框架。</p><p>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/spring-overview.png" alt="spring-overview"></p><h1 id="三spring-框架组件">三、Spring 框架组件</h1><table><thead><tr class="header"><th>GroupId</th><th>ArtifactId</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>org.springframework</td><td>spring-aop</td><td>Proxy-based AOP support 基于代理的 AOP 支持</td></tr><tr class="even"><td>org.springframework</td><td>spring-aspects</td><td>AspectJ based aspects 基于 AspectJ 的切面</td></tr><tr class="odd"><td>org.springframework</td><td>spring-beans</td><td>Beans support, including Groovy Bean 支持，包括 Groovy</td></tr><tr class="even"><td>org.springframework</td><td>spring-context</td><td>Application context runtime, including scheduling and remotingabstractions 应用程序上下文运行时，包括调度和远程抽象</td></tr><tr class="odd"><td>org.springframework</td><td>spring-context-support</td><td>Support classes for integrating common third-party libraries into aSpring application context 支持将常见的第三方库集成到 Spring应用程序上下文中的类</td></tr><tr class="even"><td>org.springframework</td><td>spring-core</td><td>Core utilities, used by many other Spring modules核心应用程序，由许多其他 Spring 模块使用</td></tr><tr class="odd"><td>org.springframework</td><td>spring-expression</td><td>Spring Expression Language (SpEL)，提供 spel表达式支持，支持设置和获取属性值,属性赋值,方法调用,访问数组的内容,集合和索引器,逻辑和算术运算符,命名变量,以及通过 Spring IoC 容器中的名称检索对象。它还支持列表投影和选择以及公共列表聚合</td></tr><tr class="even"><td>org.springframework</td><td>spring-instrument</td><td>Instrumentation agent for JVM bootstrapping JVM 引导的工具代理</td></tr><tr class="odd"><td>org.springframework</td><td>spring-instrument-tomcat</td><td>Instrumentation agent for Tomcat Tomcat 的工具代理</td></tr><tr class="even"><td>org.springframework</td><td>spring-jdbc</td><td>JDBC support package, including DataSource setup and JDBC accesssupport JDBC 支持包，包括 DataSource 设置和 JDBC访问支持，模块提供了一个 JDBC 抽象层，消除了对繁琐的 JDBC编码和解析数据库供应商特定的错误代码的需要</td></tr><tr class="odd"><td>org.springframework</td><td>spring-jms</td><td>JMS support package, including helper classes to send and receiveJMS messages JMS 支持包，包括用于发送和接收 JMS 消息的助手类，模块（Java消息服务）包含用于生成和使用消息的功能。从 Spring Framework 4.1开始，它提供了与 spring-messaging 模块的集成</td></tr><tr class="even"><td>org.springframework</td><td>spring-messaging</td><td>Support for messaging architectures and protocols支持消息架构和协议</td></tr><tr class="odd"><td>org.springframework</td><td>spring-orm</td><td>Object/Relational Mapping, including JPA and Hibernate support对象/关系映射，包括 JPA 和 Hibernate 与MyBatis支持，模块为流行的对象关系映射 API 提供集成层，包括 JPA 和Hibernate。使用 spring-orm 模块，您可以使用这些 O / R 映射框架结合Spring 提供的所有其他功能，例如前面提到的简单声明式事务管理功能</td></tr><tr class="even"><td>org.springframework</td><td>spring-oxm</td><td>Object/XML Mapping 对象/ XML 映射</td></tr><tr class="odd"><td>org.springframework</td><td>spring-test</td><td>Support for unit testing and integration testing Spring components支持单元测试和集成测试的 Spring组件,模块支持使用<code>JUnit</code>或<code>TestNG</code>对<code>Spring</code>组件进行单元测试和集成测试。它提供了<code>SpringApplicationContexts</code>的一致加载和这些上下文的缓存。它还提供了<a href="http://docs.spring.io/spring/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#mock-objects">mockobjects</a>(模拟对象)，您可以使用它来单独测试您的代码</td></tr><tr class="even"><td>org.springframework</td><td>spring-tx</td><td>Transaction infrastructure, including DAO support and JCAintegration 事务基础设施，包括 DAO支持和集成制定，模块支持实现特殊接口的类以及所有 POJO（普通 Java对象）的编程和声明事务管理</td></tr><tr class="odd"><td>org.springframework</td><td>spring-web</td><td>Web support packages, including client and web remoting Web支持包，包括客户端和 Web 远程处理，模块提供基本的面向 Web的集成功能，例如多部分文件上传功能和使用 Servlet 侦听器和面向 Web的应用程序上下文来初始化 IoC 容器。 它还包含一个 HTTP 客户端和 Web的相关部分的 Spring 的远程支持</td></tr><tr class="even"><td>org.springframework</td><td>spring-webmvc</td><td>REST Web Services and model-view-controller implementation for webapplications Web 应用程序的 REST Web 服务和模型 - 视图 -控制器实现，模块（也称为 Web-Servlet 模块）包含用于 Web 应用程序的Spring 的模型视图控制器（MVC）和 REST Web 服务实现。 Spring 的 MVC框架提供了 domain model（领域模型）代码和 Web表单之间的清晰分离，并且集成了 Spring Framework 所有的其他功能</td></tr><tr class="odd"><td>org.springframework</td><td>spring-websocket</td><td>WebSocket and SockJS implementations, including STOMP supportWebSocket 和 SockJS 实现，包括 STOMP 支持</td></tr></tbody></table><h1 id="四核心组件说明">四、核心组件说明</h1><ul><li><strong>Spring Core</strong>：Spring核心模块，主要提供 ioC依赖注入</li><li><strong>Spring Context</strong>：向Spring框架提供上下文信息</li><li><strong>Spring AOP</strong>：面向切面编程，为基于 Spring的应用程序中的对象提供了事务管理服务</li><li><strong>Spring JDBC</strong>：Java数据库连接</li><li><strong>Spring JMS</strong>：Java消息服务</li><li><strong>Spring ORM</strong>：用于支持 MyBatis、Hibernate 等 ORM工具</li><li><strong>Spring Web</strong>：为创建Web应用程序提供支持</li><li><strong>Spring Test</strong>：提供了对 JUnit 和 TestNG测试的支持</li><li><strong>SpringAspects</strong>：该模块为与AspectJ的集成提供支持</li><li><strong>SpringWeb</strong>：Spring框架支持与Struts集成，为基于web的应用程序提供了上下文</li></ul><h1 id="五spring的优点">五、Spring的优点</h1><ul><li><strong>方便解耦，简化开发 （高内聚低耦合）</strong></li></ul><p>Spring就是一个大工厂（容器），可以将所有对象创建和依赖关系维护，交给Spring管理，spring工厂是用于生成bean</p><ul><li><strong>AOP编程的支持</strong></li></ul><p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能</p><ul><li><strong>声明式事务的支持</strong></li></ul><p>只需要通过配置就可以完成对事务的管理，而无需手动编程</p><ul><li><strong>方便程序的测试</strong></li></ul><p>Spring对Junit4支持，可以通过注解方便的测试Spring程序</p><ul><li><strong>方便集成各种优秀框架</strong></li></ul><p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持</p><ul><li><strong>降低JavaEE API的使用难度</strong></li></ul><p>Spring 对 JavaEE 开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API应用难度大大降低</p><h1 id="六iocinversion-of-control控制反转">六、IoC（Inversion ofControl）控制反转</h1><p>了解Ioc之前，先了解一下<code>DI（Dependency Injection）</code>(依赖注入)</p><p><code>IoC</code> 需要<code>DI</code>(依赖注入)的支持为什么呢？因为没有 DI 的注入 Spring创造出的对象都是空值是无法使用的,所以说 <code>IoC</code> 和<code>DI</code> 多数是同时出现人们眼前的。</p><p><code>IOC</code> 是 <code>Inversion of Control</code>的缩写，多数书籍翻译成“控制反转”。<strong>为了解决对象之间的耦合度过高的问题</strong>，软件专家Michael Mattson 提出了 IOC理论，用来实现对象之间的<strong>解耦</strong>。</p><p>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（DependencyInjection）”。他的这个答案，实际上给出了实现 IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p><code>DI</code>可以被认为是一种Ioc容器构想的实现方法，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指<strong>通过引入IOC 容器，利用依赖关系注入的方式，实现对象之间的解耦。</strong></p><p><strong>将原本在程序中自己手动创建对象的控制权，交由 Spring框架来管理</strong>。Spring框架负责控制对象的<strong>生命周期</strong>和<strong>对象之间的关系</strong>。IoC在其他语言中也有应用，并非 Spirng 特有。<strong>ioc 容器实际上就是个map（key，value），里面存的是各种对象</strong>（在xml里配置的bean节点||repository、service、controller、component）。</p><p><strong>Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong>IOC容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p><p>在实际项目中一个 Service类如果有几百甚至上千个类作为它的底层，我们需要实例化这个Service，你可能要每次都要搞清这个 Service所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p><strong>IoC容器的初始化过程可以分为三步：</strong></p><ol type="1"><li>Resource 定位（Bean的定义文件定位）</li><li>将 Resource 定位好的资源载入到 BeanDefinition（BeanDefinition中保存了我们的 Bean 信息，比如这个 Bean指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean等等）</li><li>将 BeanDefiniton 注册到容器中（BeanFactory）</li></ol><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/image-20240813144751993.png" alt="image-20240813144751993"></p><p>详见：<a href="https://javadoop.com/post/spring-ioc">SpringIoc源码分析</a></p><h1 id="七aopaspect-orientedprogramming面向切面编程">七、AOP（Aspect-OrientedProgramming）面向切面编程</h1><p>AOP（Aspect Oriented Programming面向切面编程），在程序开发中主要用来解决一些系统层面上的问题，比如<strong>日志收集，事务管理，权限，缓存，对象池管理</strong>等。</p><p>AOP 可以说是 OOP（Object OrientedProgramming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如<strong>安全性、异常处理和透明的持续性</strong>也都是如此，这种散布在各处的无关的代码被称为横切（crosscutting），在 OOP设计中，它导致了<strong>大量代码的重复，而不利于各个模块的重用</strong>。</p><p>AOP技术恰恰相反，它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，<strong>便于减少系统的重复代码，降低模块之间的耦合度</strong>，并有<strong>利于未来的可操作性和可维护性</strong>。</p><p>它实际做的就是将业务和一些非业务进行拆解，降低彼此业务模块与非业务模块的耦合度，便于后续的扩展维护。例如<code>权限校验</code>、<code>日志管理</code>、<code>事务处理</code>等都可以使用<code>AOP</code>实现。而<code>Spring</code>就是基于动态代理实现<code>AOP</code>的。如果被代理的类有实现接口的话，就会基于<code>JDK Proxy</code>完成代理的创建。反之就是通过<code>Cglib</code>完成代理创建。</p><p><strong>核心术语：</strong></p><ol type="1"><li><code>目标(Target)</code>:这就被代理的对象，例如我们希望对<code>UserService</code>每个方法进行<code>增强(在不动它的代码情况下增加一些非业务的动作)</code>，那么这个<code>UserService</code>就是目标。</li><li><code>代理(Proxy)</code>:就是给你被代理后的对象的厂商，例如我们上面说过希望对<code>UserService</code>每个方法进行增强，那么给用户返回增强后的对象的类就是<code>代理类</code>。</li><li><code>连接点(JoinPoint)</code>:目标对象，每一个可能可以被增强的方法都可以称为连接点，尽管它最后可能不会被增强。</li><li><code>切入点(Pointcut)</code>:连接点中确确实实被做增强操作的方法就叫切入点。</li><li><code>通知(Advice)</code>:不要被表面的语义误导，通知并不是告知某人的意思，通知的意思是拦截对象后，做的增强操作。</li><li><code>切面(Aspect)</code>:切入点<code>(Pointcut)</code>+通知<code>(Advice)</code></li><li><code>织入(Weaving)</code>：把通知的动作融入到对象中，生成代理对象的过程就叫做织入。</li></ol><h2 id="71-spring-aop">7.1 Spring AOP</h2><p>Spring AOP就是基于动态代理的，底层实现有俩种方式：一种是 <strong>JDK动态代理(JDK Proxy)</strong>，另一种是 <strong>CGLib</strong>(CodeGeneration Library(基于字节码操作)) 的方式。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/img202304071136659.png" alt="在这里插入图片描述"></p><ul><li><strong>静态代理</strong>通过实现被代理类所实现的接口，内部保存被代理类的引用，在实现的方法中对处理逻辑进行<strong>增强</strong>，真正的方法执行调用被代理对象的方法。<strong>静态代理</strong>比较简洁直观，不过每个目标对象都需要创建一个代理类，在复杂的场景下需要创建大量的代理类，不易于维护，也不易于扩展，我们更加注重的应该是业务开发，对于这一层<strong>增强</strong>处理应该抽取出来。</li><li><strong>JDK 动态代理</strong>基于接口代理，在 JVM运行时通过反射机制生成一个实现代理接口的类，在调用具体方法时会调用InvokeHandler 来进行处理。</li><li><strong>CGLIB 动态代理</strong>基于类代理（字节码提升），通过ASM（Java 字节码的操作和分析框架）将被代理类的 class文件加载进来，通过修改其字节码生成一个子类来处理。</li></ul><p>当然，也可以使用 AspectJ ，AspectJ 可以做Spring AOP干不了的事情，它是AOP 编程的完全解决方案。</p><h2 id="72-spring-aop-和-aspectj-aop-的区别">7.2 Spring AOP 和 AspectJAOP 的区别</h2><p><strong>Spring AOP 属于运行时增强；而 AspectJ是编译时增强</strong>。Spring AOP 只能在运行时织入，AspectJ运行时织入不可用，支持编译时、编译后和加载时织入。</p><p>AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP相对来说更简单。</p><h2 id="73-aspectj-aop通知类型">7.3 AspectJ AOP通知类型</h2><ol type="1"><li><code>Before（前置通知）</code>: 目标对象方法调用前触发增强。</li><li><code>After （后置通知）</code>:目标对象方法调用后进行增强。</li><li><code>AfterReturning（返回通知）</code>:目标对象方法执行结束，返回值时进行增强。</li><li><code>AfterThrowing（异常通知）</code>:目标对象方法执行报错并抛出时做的增强。</li><li><code>Around(环绕通知）</code>:这个比较常用了，目标对象方法调用前后我们可以做各种增强操作,甚至不调用对象的方法都能做到。</li></ol><h2 id="74-多个切面执行顺序我们如何确定">7.4多个切面执行顺序我们如何确定</h2><ol type="1"><li>注解法:使用<code>@Order</code>注解来决定切面<code>bean</code>的执行顺序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> {}</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>继承接口法:<code>implements Ordered</code>接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> {</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="八spring-的-bean">八、Spring 的 bean</h1><h2 id="81-作用域scope">8.1 作用域（Scope）</h2><table><thead><tr class="header"><th>type</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>singleton</td><td>单例作用域，在SpringloC容器中仅存在一个Bean实例，Bean以单例方式存在，默认值</td></tr><tr class="even"><td>prototype</td><td>原型作用域（多例作用域），每次从容器中调用Bean时，都返回一个新的实例，即<br>每次调用getBean()时，相当于执行newXxxBean()</td></tr><tr class="odd"><td>request</td><td>请求作用域，该作用域仅适用于WebApplicationContext环境，具体为SpringMVC下使用</td></tr><tr class="even"><td>session</td><td>会话作用域，每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境，具体为SpringMVC下使用</td></tr><tr class="odd"><td>application</td><td>全局作用域，同一个HTTPSession共享一个Bean，该作用域仅适用于WebApplicationContext环境，具体为SpringMVC下使用</td></tr></tbody></table><h2 id="82-springbean的线程安全问题">8.2 SpringBean的线程安全问题</h2><p>线程安全一直是代码编写的重地，我们大多时候在系统开发中不会使用多线程。单例bean存在线程安全问题，当多个线程操作同一个对象的时候，这个对象的非静态成员变量会存在线程安全问题。</p><p>解决方法：</p><ul><li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal 中（推荐的一种方式，这也是常用一种）；</li><li>在Bean对象中尽量避免定义可变的成员变量。</li></ul><h2 id="83-spring-bean-的生命周期">8.3 Spring bean 的生命周期</h2><p>在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean的实例化，然后该Bean就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。</p><p>相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean的生命周期非常重要。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/image-20240813170530963.png" alt="image-20240813170530963"></p><p>由此可以得出，Bean的三种自定义初始化和销毁方法</p><ul><li>在配置类中指定 @Bean(initMethod = “init”,destroyMethod =“destory”)注解</li><li>实现InitializingBean接口并重写其afterPropertiesSet方法，实现DisposableBean接口并重写destroy方法</li><li>利用java的JSR250规范中的@PostConstruct标注在init方法上，@PreDestroy标注在destroy方法上</li></ul><h2 id="84-spring-mvc">8.4 Spring MVC</h2><p>Spring MVC 是一款很优秀的 MVC 框架。可以让我们的开发更简洁，而且它和Spring 是无缝集成，是 Spring 的一个子模块，是我们上面提到 Spring大家族中 Web 模块。</p><p>Spring MVC 框架主要由 <strong>DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图</strong>组成。</p><h3 id="springmvc-arch3"><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/SpringMVC-arch3.png" alt="SpringMVC-arch3"></h3><h1 id="九spring管理事务">九、Spring管理事务</h1><h2 id="91-事务管理方式">9.1 事务管理方式</h2><blockquote><p>事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p></blockquote><ol type="1"><li><strong>编程式事务，在代码中硬编码。(不推荐使用)</strong></li></ol><p>所谓编程式事务指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。</p><p>Spring框架提供了两种编程式事务方式：</p><ul><li>使用TransactionTemplate</li><li>使用PlatformTransactionManager</li></ul><p>Spring团队通常<strong>建议使用TransactionTemplate</strong>进行程序化事务管理。</p><p>TransactionTemplate采用与其他spring模板相同的方法，它使用一种回调方法，使应用程序代码可以处理获取和释放事务资源，让开发人员更加专注于业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                } <span class="keyword">catch</span> (Exception e){</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>声明式事务，在配置文件中配置（推荐使用）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String userName)</span>{</span><br><span class="line">    <span class="built_in">this</span>.jdbcTemplate.update(<span class="string">"insert into t_user (name) values (?)"</span>, userName);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>声明式事务</strong>又分为两种：</p><ul><li>基于XML的声明式事务</li><li>基于注解的声明式事务</li></ul><h2 id="92-声明式事务注意点">9.2 声明式事务注意点</h2><p><strong>@Transactional(rollbackFor =Exception.class)注解</strong></p><p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code> 属性,那么事物只会在遇到<code>RuntimeException</code> 的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p><p><code>@Transactional</code>是通过SpringAOP代理增强的方式进行事务的管理与控制的，所以<code>@Transactional</code>只能<strong>加在public方法</strong>上，且<strong>调用方不能是同一个类中的方法（JDK代理模式时）</strong></p><h2 id="93-spring管理事务原理说明">9.3 Spring管理事务原理说明</h2><p>Spring事务的本质 其实就是 AOP 和 数据库事务，Spring将数据库的事务操作提取为 切面，通过 aop在方法执行前后增加数据库事务的操。</p><p>1、在方法开始时判断是否开启新事务，需要开启事务则设置事务手动提交 setautocommit=0;</p><p>2、在方法执行完成后手动提交事务 commit;</p><p>3、在方法抛出指定异常后调用 rollback 回滚事务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一spring框架学习路线图&quot;&gt;一、Spring框架学习路线图&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/spring%E6%A1%86%E6</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Java" scheme="https://www.junpengzhou.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Office2021安装</title>
    <link href="https://www.junpengzhou.top/article/82d0f8f4.html"/>
    <id>https://www.junpengzhou.top/article/82d0f8f4.html</id>
    <published>2024-08-12T03:23:32.000Z</published>
    <updated>2024-08-12T03:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于微软在Office2016之后的版本均不提供ISO镜像下载（指正版商业镜像），VL版本的Office需要管理员手动使用ODT工具进行部署。</p><h1 id="一下载odt工具">一、下载ODT工具</h1><p>ODT工具下载： <a href="https://www.microsoft.com/en-us/download/details.aspx?id=49117">官方下载地址</a></p><p>点击<code>[Download]</code>按钮下载微软官网提供的ODT工具，下载下来的是一个自解压程序的压缩包，双击选择解压位置，你就会得到一个红色图标的<code>setup.exe</code>和一些示例的xml文件。我们只要其中的<code>setup.exe</code>即可。</p><h1 id="二定制自己的office套件">二、定制自己的Office套件</h1><p><a href="https://config.office.com/deploymentsettings">点击此处开始配置</a>打开上面的微软Office提供的Office配置定制网站，可以自由地定制想要的Office。此处仅介绍几个重点：</p><ul><li>版本选择：请选择带<code>批量许可证</code>字样的版本，同时请不要选择带<code>SPLA</code>字样的版本。（注意：如果你要安装Visio之类的组件，LTSC版本会和个人版OFFICE冲突，如果你电脑上有个人版OFFICE导致安装冲突请不要选择带LTSC字样版本。）</li><li>你可以自由选择安装的组件和语言，比如仅安装Word，Excel和PowerPoint。</li><li>授权和激活：开启自动接受EULA，点选KMS选项。</li><li>DIY好你心仪的配置之后，可以点击<code>导出</code>按钮，如有询问默认文件格式点击<code>[保留当前配置]</code>即可。<em><strong>你将会下载到一个xml格式的配置文件，为了后续操作方便，你可以重命名为<code>office.xml</code>。</strong></em></li></ul><h1 id="三开始安装office">三、开始安装Office</h1><p>把步骤1得到的setup.exe和步骤2得到的office.xml放在同一个目录，在当前目录的地址栏输入cmd回车，打开命令提示符窗口，输入以下命令即可执行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup.exe /configure office.xml</span><br></pre></td></tr></table></figure><p>将下面脚本保存为step1.bat，并与setup.exe与刚刚所生成的xml文件放置同目录下，然后双击运行即可安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo @off</span><br><span class="line">setup.exe /configure officeandvisio.xml</span><br></pre></td></tr></table></figure><h1 id="四激活office2021">四、激活Office2021</h1><p>将以下脚本保存为step2.bat，安装完office后双击运行以激活office！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">chcp 65001</span><br><span class="line">"%windir%\System32\cscript" "%ProgramFiles%\Microsoft Office\Office16\ospp.vbs" /sethst:kms.03k.org</span><br><span class="line">"%windir%\System32\cscript" "%ProgramFiles%\Microsoft Office\Office16\ospp.vbs" /act</span><br><span class="line">echo '是否出现&lt;Product activation successful&gt;关键词，出现则表示激活成功！'</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>脚本中其中<code>/sethst:</code>后紧跟着的域名为kms服务器域名，其中KMS站点测试情况：<a href="https://www.coolhub.top/tech-articles/kms_list.html">kms站点列表</a></p><h1 id="五再次检查激活状态">五、再次检查激活状态</h1><p>随意打开一个word或者ppt文件，找到<code>文件</code>-&gt;<code>账户</code>-&gt;<code>产品信息</code>查看是否激活！</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/image-20240812114533020.png" alt="image-20240812114533020"></p><h1 id="六常见问题排查">六、常见问题排查</h1><h2 id="61-执行cscript-osppvbs-sethstxxxxxxxxx报错0x80070005解决思路">6.1执行<code>cscript ospp.vbs /sethst:xxx.xxx.xxx</code>报错：<code>0x80070005</code>解决思路</h2><ol type="1"><li>Windows11请勿使用cmd启动，可搜索栏搜索<code>终端</code>右键管理员启动（或使用powershell）</li><li>提高操作权限，使用右键管理员身份运行脚本</li></ol><h2 id="62-提示0xc004f074软件授权服务报告无法激活计算机无法联系任何密钥管理服务kmsno-kms-could-be-contacted">6.2提示0xC004F074软件授权服务报告无法激活计算机，无法联系任何密钥管理服务（KMS）nokms could be contacted</h2><ol type="1"><li><p>KMS服务器宕机或者你的网络断了导致无法连接，使用<code>vlmcs kms.example.com</code>来测试KMS服务器是否有正常返回(successful)。<a href="https://github.com/kkkgo/vlmcsd/releases">vlmcs工具下载</a></p></li><li><p>第三方KMS激活工具，把系统的软件服务激活劫持了，无论你设置什么KMS地址都会劫持到本地去，这种情况可能没什么比较通用的解决方法，可以用下面的方法尝试检查下注册表的劫持项，不行就重开吧：打开注册表<strong>HKLM\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Image File Execution Options</strong>定位到(如果有)<strong>SppExtComObj.exe，sppsvc.exe，osppsvc.exe</strong>，删除这些项。</p></li></ol><p>本文参考自：<a href="https://blog.03k.org/post/dowload-vloffice.html">https://blog.03k.org/post/dowload-vloffice.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于微软在Office
2016之后的版本均不提供ISO镜像下载（指正版商业镜像），VL版本的Office需要管理员手动使用ODT工具进行部署。&lt;/p&gt;
&lt;h1 id=&quot;一下载odt工具&quot;&gt;一、下载ODT工具&lt;/h1&gt;
&lt;p&gt;ODT工具下载： &lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="软件安装" scheme="https://www.junpengzhou.top/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>计算机千年虫问题</title>
    <link href="https://www.junpengzhou.top/article/cff57d86.html"/>
    <id>https://www.junpengzhou.top/article/cff57d86.html</id>
    <published>2024-08-12T02:27:56.000Z</published>
    <updated>2024-08-12T02:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2000年问题">2000年问题</h1><p><strong>2000年问题</strong>（英语：Year 2000Problem），在英文中也被简称为<strong>Y2K</strong>，在中国大陆及香港常被称为<strong>千年虫问题</strong>，台湾则称<strong>千禧蟲危机</strong>，是指由于当时的计算机程序在日期表达上的设计问题，从而导致计算机会误读在2000年后的一些日期，并进一步导致计算机出现错误所引起的计算机问题，当时的计算机程序普遍采用6位数字来存储时间，只显示四位数字后的两位数字，但这又会导致计算机系统紊乱，使其无法区分2000年与1900年，从而导致了误读问题，并导致计算机紊乱。2000年问题可能会威胁到那些运行在重要行业中的计算机与大量社会基础设施，甚至影响到政府部门与军队。从而导致停水、断电，银行瘫痪，最极端的情况下，它甚至可能会导致核电厂发生事故，核武器与导弹失控以及交通与通信的中断，并最终引发灾难性的后果。</p><p>这个悬挂于南特中央理工学院的电子标志将2000年1月3日错误显示为了1900年1月3日。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/Bug_de_l&#39;an_2000.jpg" alt="Bug_de_l'an_2000"></p><p>但最终，在2000年问题引起社会广泛重视后，它得到了足够的关注与处理，最终在规模庞大的修复行动后，它没有在新千年到来之际引起全球电脑系统的大规模瘫痪。</p><h1 id="程序问题本源">程序问题本源</h1><p>两千年问题始于1960年代，当时计算机内存和外部存储介质的成本很高，大多数数据处理需要借助穿孔卡片。为了节省硬件成本，葛丽丝·霍普在HarvardMarkI上以6位数字来存储时间，即年、月、日各两位。这个习惯被COBOL继承下来，传播到整个计算机程序界。</p><p>当时的编程语言，如COBOL和RPG，使用ASCII和EBCDIC编码表示数据。如果用四位数字表示年份，就要多占用存储介质空间，使成本增加；因此为了节省存储空间，计算机系统的编程人员采用两位数字表示年份。随着计算机技术的迅猛发展，存储介质的价格逐步下降，但在计算机系统中使用两位数字来表示年份的做法却由于惯性思维而被沿袭下来；对大多数程序员来说，他们并不认为所编写的软件会持续使用很多年。</p><p>具体来讲，两千年问题要解决的事项包括以下几个要点：</p><p>软件在特定的日期会否出现运作错误。要留意的日期包括以下几个日子：</p><ul><li>1999年1月1日</li><li>1999年4月9日（1999年的第99日）</li><li>1999年9月9日</li><li>1999年12月31日</li><li>2000年1月1日</li><li>2000年2月28日</li><li>2000年2月29日</li><li>2025年1月1日（昭和100年问题）</li><li>2038年1月19日（参见2038年问题）</li><li>2099年1月1日</li><li>2099年4月9日</li><li>2099年9月9日</li><li>2099年12月31日</li><li>2111年11月11日</li></ul><p>软件会不会利用特定的日期格式来表示档案完结，或档案已删除。软件会否出现错误的日期，如“19100年”或“3000年”。两千年问题是由鲍伯·贝默在1958年第一次提出的。在其后的二十年里，他用了很大的努力，希望政府、企业和国际组织（如IBM和ISO）来关注这个问题，但反响寥寥。直到2000年将要到来的时候，人们才感觉到两千年问题的紧迫性。于是社会和政府都投入了大量的人力和物力来避免发生大规模的计算机灾难。而从现在来看，这些努力也获取了相应的成果。</p><p>总结：本质问题在于程序设计之初的历史背景与环境因素有关，由于存储空间的有限，加上忽略了业务膨胀速度所导致的问题。现在这样的情况也不断的在上演，程序员们对于业务的考虑大多也仅局限于10年内的业务发展考量。</p><h1 id="2038问题">2038问题</h1><p>在计算机应用上，2038年问题可能会导致某些软件在2038年1月19日3时14分07秒之后无法正常工作。所有使用POSIX时间表示时间的程序都将受其影响，因为它们以自1970年1月1日经过的秒数（忽略闰秒）来表示时间[1]。这种时间表示法在类Unix（Unix-like）操作系统上是一个标准，并会影响以其C编程语言开发给其他大部分操作系统使用的软件。在大部分的32位操作系统上，此“time_t”数据模式使用一个有正负号的32位整数（signedint32）存储计算的秒数。依照此“time_t”标准，在此格式能被表示的最后时间是2038年1月19日03:14:07，星期二（UTC）。超过此一瞬间，时间将会“绕回”（wraparound）且在内部被表示为一个负数，并造成程序无法工作，因为它们无法将此时间识别为2038年，而可能会依个别实现而跳回1970年或1901年。因此可能产生错误的计算及动作。</p><p>有少数的情况下，在制定规格时，特别规定以无正负号的32位整数（unsignedint32）存储POSIX时间，因此错误会被延后到2106年。例如比特币区块链中的区块时间戳记，就是以这种方法存储。[2][3]</p><p>目前并没有针对现有的CPU／操作系统搭配的简单解决方案。直接将POSIX时间更改为64位模式将会破坏对于软件、数据存储以及所有与二进制表示时间相关的部分的二进位兼容性。更改成无符号的32位整数则会影响许多与两时间之差相关的程序。不过，那时使用32位系统的计算机可能会很少。</p><p>大部分64位操作系统已经把time_t这个系统变量改为64位宽。不过，其他现有架构的改动仍在进行中，不过预期“应该可以在2038年前完成”。然而，直到2006年，仍然有数以亿计的32位系统在运行中，特别是许多嵌入式系统。相对于一般电脑科技18至24个月的革命性更新，嵌入式系统可能直至使用寿命终结都不会改变。32位time_t的使用亦被编码于文件格式，例如众所周知的ZIP文件压缩格式。其能存在的时间远比受影响的机器长。</p><p>新的64位运算器可以记录至约2900亿年后的292,277,026,596年12月4日15:30:08，星期日（UTC）。</p><p><img src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/640" alt="图片"></p><h2 id="32位操作系统">32位操作系统</h2><p>在计算机应用上，2038年问题可能会导致某些软件在2038年1月19日3时14分07秒之后无法正常工作。</p><p>所有使用POSIX时间表示时间的程序都将受其影响，因为它们以自1970年1月1日经过的秒数（忽略闰秒）来表示时间。</p><p>在大部分的32位操作系统上，time_t使用一个有正负号的32位有符号整数存储计算的秒数。依照time_t标准，在此格式能被表示的最后时间是2038年1月19日03:14:07，星期二（UTC）。</p><p>一旦超过这个时刻，时间将会绕回且在内部被表示为一个负数，并造成程序无法工作，因为它们无法将此时间识别为2038年，而可能会依个别实现而跳回1970年或1901年。因此可能产生错误的计算及动作。</p><h2 id="64位操作系统">64位操作系统</h2><p>大部分64位操作系统已经把time_t这个系统变量改为64位，但是仍然有数以亿计的32位系统在运行中，特别是许多嵌入式系统。</p><p>32位time_t的使用亦被编码于文件格式，例如众所周知的ZIP文件压缩格式。其能存在的时间远比受影响的机器长。</p><p>新的64位运算器可以记录至约2900亿年后的292,277,026,596年12月4日15:30:08，星期日（UTC），基本上可以彻底解决时间回环问题。</p><h1 id="对比2038问题与千年虫问题">对比2038问题与千年虫问题</h1><p>2038年问题与之前的千年虫问题的杀伤力是不一样的，千年虫属于应用程序的问题，而2038年问题却是系统级的，有更大的杀伤力。</p><p>Linux Kernel 5.6 的开发者已经准备好着手解决将在下一个十年到来的 2038年问题。Linux 5.6 也成为第一个为 32 位系统准备运行到 2038年之后的主线内核。</p><p>至于像MySQL等组件同样面临2038年问题，目前还有17年的时候，我们相信可以应对这次危机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2000年问题&quot;&gt;2000年问题&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;2000年问题&lt;/strong&gt;（英语：Year 2000
Problem），在英文中也被简称为&lt;strong&gt;Y2K&lt;/strong&gt;，在中国大陆及香港常被称为&lt;strong&gt;千年虫问题&lt;/str</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="操作系统" scheme="https://www.junpengzhou.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>修改potplayer的代理</title>
    <link href="https://www.junpengzhou.top/article/a0aebb8b.html"/>
    <id>https://www.junpengzhou.top/article/a0aebb8b.html</id>
    <published>2024-08-06T08:01:29.000Z</published>
    <updated>2024-08-06T08:01:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Proxifier注册码序列号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L6Z8A-XY2J4-BTZ3P-ZZ7DF-A2Q9C（Portable Edition）#免安装版本</span><br><span class="line"></span><br><span class="line">5EZ8G-C3WL5-B56YG-SCXM9-6QZAP（Standard Edition）#安装版本</span><br><span class="line"></span><br><span class="line">P427L-9Y552-5433E-8DSR3-58Z68（MAC） #mac版本</span><br></pre></td></tr></table></figure><p>otPlayer软件本身没有代理这个功能，需要借助专门的代理桌面软件才能实现播放被屏蔽的直播源、YOUTUBE视频。</p><p>首先你要有代理账号，安装了科学上网软件。</p><p>安装Proxifier <a href="http://www.hanzify.org/software/13717.html">http://www.hanzify.org/software/13717.html</a>，添加代理服务器IP127.0.0.1，端口1080。</p><p>代理规则可以设置Default全局所有的软件都走代理。也可以新建一个只允许PotPlayer走代理，Default全局direct直接连接的规则。</p><p>此时PotPlayer就能使用代理访问被墙的视频了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Proxifier注册码序列号&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql通过binlog恢复误修改的数据</title>
    <link href="https://www.junpengzhou.top/article/cbccf131.html"/>
    <id>https://www.junpengzhou.top/article/cbccf131.html</id>
    <published>2024-07-30T07:21:16.000Z</published>
    <updated>2024-07-30T07:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>binlog日志文件，且binlog日志格式为row时记录所有数据库表结构变更（例如CREATE、ALTERTABLE…等操作）以及表数据修改（INSERT、UPDATE、DELETE…等操作）的二进制日志，会在日志中详细记录数据库表结构变更详情及表数据修改的详细内容。因为binlog日志文件是二进制文件，没法用文本编辑器等直接打开查看，这时就需要mysql的自带的mysqlbinlog工具进行解码</p><h1 id="如何开启binlog日志">如何开启binlog日志</h1><p>修改mysql的my.cnf配置文件 一般默认是在/etc/my.cnf路径下</p><p>简单开启binlog demo 在mysqld下添加第一种方式</p><p>#第一种方式:</p><p>#开启binlog日志 log_bin=ON #binlog日志的基本文件名log_bin_basename=/var/lib/mysql/mysql-bin#binlog文件的索引文件，管理所有binlog文件log_bin_index=/var/lib/mysql/mysql-bin.index #配置serveridserver-id=1</p><p>在mysqld下添加第二种方式</p><p>#第二种方式:#此一行等同于上面log_bin三行,这里可以写绝对路径,也可以直接写mysql-bin(后者默认就是在/var/lib/mysql目录下)log-bin=/var/lib/mysql/mysql-bin #配置serverid server-id=1</p><p>修改完配置后，重启mysql。执行SHOW VARIABLES LIKE 'log_bin'; Value值为 ON即可。</p><h1 id="使用mysqlbinlog命令导出对应时间内的binlog">使用mysqlbinlog命令导出对应时间内的binlog</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv --database=yyds --start-datetime="2024-06-27 14:09:00" --stop-datetime="2024-06-27 14:11:00" mysql-bin.000023 &gt; 202406271410binlog.sql</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;binlog日志文件，且binlog日志格式为row时记录所有数据库表结构变更（例如CREATE、ALTER
TABLE…等操作）以及表数据修改（INSERT、UPDATE、DELETE…等操作）的二进制日志，会在日志中详细记录数据库表结构变更详情及表数据修改的详细内容。
</summary>
      
    
    
    
    <category term="技术分享" scheme="https://www.junpengzhou.top/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="建站经验" scheme="https://www.junpengzhou.top/tags/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
