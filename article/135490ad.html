<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>JVM系列-JVM内存结构 | AlphaDog</title><meta name="keywords" content="Java,JVM"><meta name="author" content="Junpengzhou"><meta name="copyright" content="Junpengzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JVM系列-JVM内存结构"><meta name="application-name" content="JVM系列-JVM内存结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JVM系列-JVM内存结构"><meta property="og:url" content="https://www.junpengzhou.top/article/135490ad.html"><meta property="og:site_name" content="AlphaDog"><meta property="og:description" content="运行时数据区 内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。 下图是 JVM 整"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-cover.webp"><meta property="article:author" content="Junpengzhou"><meta property="article:tag" content="技术,前端,后端,美食,工程管理,数学,英语,密码学,Java,Python,机器学习,AI,读书,播客,工具"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-cover.webp"><meta name="description" content="运行时数据区 内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。 下图是 JVM 整"><link rel="shortcut icon" href="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jp-blog-favicon.ico"><link rel="canonical" href="https://www.junpengzhou.top/article/135490ad.html"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="sW9184Qb84fbHTjaHMPEyw8qv4GpWmI2gD-tTp_s"><meta name="baidu-site-verification" content="codeva-4bOPbFwZfg"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={linkPageTop:{enable:!0,title:"与众多博主共同进步",addFriendPlaceholder:"站点名称：\n网站地址：\n头像地址：\n站点描述：\n站点截图（可选）：\n"},peoplecanvas:void 0,postHeadAiDescription:void 0,diytitle:void 0,LA51:{enable:!0,ck:"3FWN3ZXqo0a6Z2Ev",LingQueMonitorID:"3FWN3ZXqo0a6Z2Ev"},greetingBox:void 0,twikooEnvId:"https://twikoo.junpengzhou.top",commentBarrageConfig:{enable:!0,maxBarrage:1,barrageTime:4e3,accessToken:"24abc38bb05941a9830b8495c2db7637",mailMd5:"CC9A3999333A6826AFEAF269B1C49D06"},music_page_default:"nav_music",root:"/",preloader:{source:3},friends_vue_info:{apiurl:"https://friendscircle.junpengzhou.top/"},navMusic:!0,mainTone:void 0,authorStatus:{skills:["🔨 全栈开发工程师","🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🏃 脚踏实地行动派","🧱 团队小组发动机"]},algolia:{appId:"S58UP7YT4C",apiKey:"ec54556c03e6ea9b3ecdb7332bf0d059",indexName:"blog_junpengzhoutop",hits:{per_page:10},languages:{input_placeholder:"输入关键词后按下回车查找",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简",rightMenuMsgToTraditionalChinese:"转为繁体",rightMenuMsgToSimplifiedChinese:"转为简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,simplehomepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{copy:!0,copyrightEbable:!0,limitCount:50,languages:{author:"作者: Junpengzhou",link:"链接: ",source:"来源: AlphaDog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",copySuccess:"复制成功，复制和转载请标注本文地址"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#3b70fc",bgDark:"#1f1f1f",position:"top-center"},source:{justifiedGallery:{js:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js",css:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,shortcutKey:void 0,autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"AlphaDog",title:"JVM系列-JVM内存结构",postAI:"",pageFillDescription:"运行时数据区, 一、程序计数器, 1.1 作用, 1.2 概述, 二、虚拟机栈, 2.1 概述, 2.2 栈的存储单位, 2.3 栈运行原理, 2.4 栈帧的内部结构, 2.4.1. 局部变量表, 槽 Slot, 2.4.2. 操作数栈, 概述, 栈顶缓存（Top-of-stack-Cashing）, JVM 是如何执行方法调用的, 虚方法和非虚方法, 虚方法表, 2.4.5. 附加信息, 三、本地方法栈, 四、堆内存, 4.1 内存划分, 年轻代 (Young Generation), 老年代(Old Generation), 元空间, 4.2 设置堆内存大小和 OOM, 查看 JVM 堆内存分配, 4.3 对象在堆中的生命周期, 4.4 对象的分配过程, 4.5 GC 垃圾回收简介, Minor GC、Major GC、Full GC, 4.6 TLAB, 为什么要有 TLAB ?, 逃逸分析, 代码优化之同步省略（消除）, 代码优化之标量替换, 代码优化之栈上分配, 五、方法区, 5.1 解惑, 5.2 设置方法区内存的大小, 5.3 方法区内部结构, 类型信息, 域（Field）信息, 方法（Method）信息, 5.4 运行时常量池, 常量池, 为什么需要常量池？, 运行时常量池, 移除永久代原因, 5.6 方法区的垃圾回收, 参考与感谢运行时数据区内存是非常重要的系统资源是硬盘和的中间仓库及桥梁承载着操作系统和应用程序的实时运行内存布局规定了在运行过程中内存申请分配管理的策略保证了的高效稳定运行不同的对于内存的划分方式和管理机制存在着部分差异下图是整体架构中间部分就是虚拟机定义的各种运行时数据区域虚拟机定义了若干种程序运行期间会使用到的运行时数据区其中有一些会随着虚拟机启动而创建随着虚拟机退出而销毁另外一些则是与线程一一对应的这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁线程私有程序计数器虚拟机栈本地方法区线程共享堆方法区堆外内存的永久代或的元空间代码缓存一程序计数器程序计数寄存器的命名源于的寄存器寄存器存储指令相关的线程信息只有把数据装载到寄存器才能够运行这里并非是广义上所指的物理寄存器叫程序计数器或计数器或指令计数器会更加贴切并且也不容易引起一些不必要的误会中的寄存器是对物理寄存器的一种抽象模拟程序计数器是一块较小的内存空间可以看作是当前线程所执行的字节码的行号指示器作用寄存器用来存储指向下一条指令的地址即将要执行的指令代码由执行引擎读取下一条指令分析进入文件所在目录执行反解析或者通过插件直接查看上图可以看到当前类对应的区汇编指令本地变量表异常表和代码行偏移量映射表常量池等信息概述通过下面两个问题理解下计数器使用寄存器存储字节码指令地址有什么用呢为什么使用寄存器记录当前线程的执行地址呢因为需要不停的切换各个线程这时候切换回来以后就得知道接着从哪开始继续执行的字节码解释器就需要通过改变寄存器的值来明确下一条应该执行什么样的字节码指令寄存器为什么会被设定为线程私有的多线程在一个特定的时间段内只会执行其中某一个线程方法会不停的做任务切换这样必然会导致经常中断或恢复为了能够准确的记录各个线程正在执行的当前字节码指令地址所以为每个线程都分配了一个寄存器每个线程都独立计算不会互相影响相关总结如下它是一块很小的内存空间几乎可以忽略不计也是运行速度最快的存储区域在规范中每个线程都有它自己的程序计数器是线程私有的生命周期与线程的生命周期一致任何时间一个线程都只有一个方法在执行也就是所谓的当前方法如果当前线程正在执行的是方法程序计数器记录的是字节码指令地址如果是执行方法则是未指定值它是程序控制流的指示器分支循环跳转异常处理线程恢复等基础功能都需要依赖这个计数器来完成字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令它是唯一一个在规范中没有规定任何情况的区域二虚拟机栈概述虚拟机栈早期也叫栈每个线程在创建的时候都会创建一个虚拟机栈其内部保存一个个的栈帧对应着一次次方法调用是线程私有的生命周期和线程一致作用主管程序的运行它保存方法的局部变量部分结果并参与方法的调用和返回特点栈是一种快速有效的分配存储方式访问速度仅次于程序计数器直接对虚拟机栈的操作只有两个每个方法执行伴随着入栈进栈压栈方法执行结束出栈栈不存在垃圾回收问题栈中可能出现的异常虚拟机规范允许虚拟机栈的大小是动态的或者是固定不变的如果采用固定大小的虚拟机栈那每个线程的虚拟机栈容量可以在线程创建的时候独立选定如果线程请求分配的栈容量超过虚拟机栈允许的最大容量虚拟机将会抛出一个异常如果虚拟机栈可以动态扩展并且在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈那虚拟机将会抛出一个异常可以通过参数来设置线程的最大栈空间栈的大小直接决定了函数调用的最大可达深度官方提供的参考工具可查一些参数和操作栈的存储单位栈中存储什么每个线程都有自己的栈栈中的数据都是以栈帧的格式存在在这个线程上正在执行的每个方法都各自有对应的一个栈帧栈帧是一个内存区块是一个数据集维系着方法执行过程中的各种数据信息栈运行原理直接对栈的操作只有两个对栈帧的压栈和出栈遵循先进后出后进先出原则在一条活动线程中一个时间点上只会有一个活动的栈帧即只有当前正在执行的方法的栈帧栈顶栈帧是有效的这个栈帧被称为当前栈帧与当前栈帧对应的方法就是当前方法定义这个方法的类就是当前类执行引擎运行的所有字节码指令只针对当前栈帧进行操作如果在该方法中调用了其他方法对应的新的栈帧会被创建出来放在栈的顶端称为新的当前栈帧不同线程中所包含的栈帧是不允许存在相互引用的即不可能在一个栈帧中引用另外一个线程的栈帧如果当前方法调用了其他方法方法返回之际当前栈帧会传回此方法的执行结果给前一个栈帧接着虚拟机会丢弃当前栈帧使得前一个栈帧重新成为当前栈帧方法有两种返回函数的方式一种是正常的函数返回使用指令另一种是抛出异常不管用哪种方式都会导致栈帧被弹出在时候可以在窗口看到中各种方法的压栈和出栈情况栈帧的内部结构每个栈帧中存储着局部变量表操作数栈或称为表达式栈动态链接指向运行时常量池的方法引用方法返回地址方法正常退出或异常退出的地址一些附加信息继续深抛栈帧中的五部分局部变量表局部变量表也被称为局部变量数组或者本地变量表是一组变量值存储空间主要用于存储方法参数和定义在方法体内的局部变量包括编译器可知的各种虚拟机基本数据类型对象引用类型它并不等同于对象本身可能是一个指向对象起始地址的引用指针也可能是指向一个代表对象的句柄或其他与此相关的位置和类型指向了一条字节码指令的地址已被异常表取代由于局部变量表是建立在线程的栈上是线程的私有数据因此不存在数据安全问题局部变量表所需要的容量大小是编译期确定下来的并保存在方法的属性的数据项中在方法运行期间是不会改变局部变量表的大小的方法嵌套调用的次数由栈的大小决定一般来说栈越大方法嵌套调用次数越多对一个函数而言它的参数和局部变量越多使得局部变量表膨胀它的栈帧就越大以满足方法调用所需传递的信息增大的需求进而函数调用就会占用更多的栈空间导致其嵌套调用次数就会减少局部变量表中的变量只在当前方法调用中有效在方法执行时虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程当方法调用结束后随着方法栈帧的销毁局部变量表也会随之销毁参数值的存放总是在局部变量数组的开始到数组长度的索引结束槽局部变量表最基本的存储单元是变量槽在局部变量表中位以内的类型只占用一个包括类型位的类型和占用两个连续的在存储前被转换为也被转换为表示非表示和则占据两个会为局部变量表中的每一个都分配一个访问索引通过这个索引即可成功访问到局部变量表中指定的局部变量值索引值的范围从开始到局部变量表最大的数量当一个实例方法被调用的时候它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个上如果需要访问局部变量表中一个的局部变量值时只需要使用前一个索引即可比如访问或类型变量不允许采用任何方式单独访问其中的某一个如果当前帧是由构造方法或实例方法创建的那么该对象引用将会存放在为的处其余的参数按照参数表顺序继续排列这里就引出一个问题静态方法中为什么不可以引用就是因为变量不存在于当前方法的局部变量表中栈帧中的局部变量表中的槽位是可以重用的如果一个局部变量过了其作用域那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位从而达到节省资源的目的下图中理论上应该有个变量复用了的槽在栈帧中与性能调优关系最为密切的就是局部变量表在方法执行时虚拟机使用局部变量表完成方法的传递局部变量表中的变量也是重要的垃圾回收根节点只要被局部变量表中直接或间接引用的对象都不会被回收操作数栈每个独立的栈帧中除了包含局部变量表之外还包含一个后进先出的操作数栈也可以称为表达式栈操作数栈在方法执行过程中根据字节码指令往操作数栈中写入数据或提取数据即入栈出栈某些字节码指令将值压入操作数栈其余的字节码指令将操作数取出栈使用它们后再把结果压入栈比如执行复制交换求和等操作概述操作数栈主要用于保存计算过程的中间结果同时作为计算过程中变量临时的存储空间操作数栈就是执行引擎的一个工作区当一个方法刚开始执行的时候一个新的栈帧也会随之被创建出来此时这个方法的操作数栈是空的每一个操作数栈都会拥有一个明确的栈深度用于存储数值其所需的最大深度在编译期就定义好了保存在方法的属性的数据项中栈中的任何一个元素都可以是任意的数据类型的类型占用一个栈单位深度的类型占用两个栈单位深度操作数栈并非采用访问索引的方式来进行数据访问的而是只能通过标准的入栈和出栈操作来完成一次数据访问如果被调用的方法带有返回值的话其返回值将会被压入当前栈帧的操作数栈中并更新寄存器中下一条需要执行的字节码指令操作数栈中元素的数据类型必须与字节码指令的序列严格匹配这由编译器在编译期间进行验证同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证另外我们说虚拟机的解释引擎是基于栈的执行引擎其中的栈指的就是操作数栈栈顶缓存的执行引擎采用的并非是基于寄存器的架构但这并不代表的实现并没有间接利用到寄存器资源寄存器是物理中的组成部分之一它同时也是中非常重要的高速存储资源一般来说寄存器的读写速度非常迅速甚至可以比内存的读写速度快上几十倍不止不过寄存器资源却非常有限不同平台下的寄存器数量是不同和不规律的寄存器主要用于缓存本地机器指令数值和下一条需要被执行的指令地址等数据基于栈式架构的虚拟机所使用的零地址指令更加紧凑但完成一项操作的时候必然需要使用更多的入栈和出栈指令这同时也就意味着将需要更多的指令分派次数和内存读写次数由于操作数是存储在内存中的因此频繁的执行内存读写操作必然会影响执行速度为了解决这个问题设计者们提出了栈顶缓存技术将栈顶元素全部缓存在物理的寄存器中以此降低对内存的读写次数提升执行引擎的执行效率动态链接指向运行时常量池的方法引用每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接在源文件被编译到字节码文件中时所有的变量和方法引用都作为符号引用保存在文件的常量池中比如描述一个方法调用了另外的其他方法时就是通过常量池中指向方法的符号引用来表示的那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用是如何执行方法调用的方法调用不同于方法执行方法调用阶段的唯一任务就是确定被调用方法的版本即调用哪一个方法暂时还不涉及方法内部的具体运行过程文件的编译过程中不包括传统编译器中的连接步骤一切方法调用在文件里面存储的都是符号引用而不是方法在实际运行时内存布局中的入口地址直接引用也就是需要在类加载阶段甚至到运行期才能确定目标方法的直接引用这一块内容除了方法调用还包括解析分派静态分派动态分派单分派与多分派这里先不介绍后续再挖在中将符号引用转换为调用方法的直接引用与方法的绑定机制有关静态链接当一个字节码文件被装载进内部时如果被调用的目标方法在编译期可知且运行期保持不变时这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接动态链接如果被调用的方法在编译期无法被确定下来也就是说只能在程序运行期将调用方法的符号引用转换为直接引用由于这种引用转换过程具备动态性因此也就被称之为动态链接对应的方法的绑定机制为早期绑定和晚期绑定绑定是一个字段方法或者类在符号引用被替换为直接引用的过程这仅仅发生一次早期绑定早期绑定就是指被调用的目标方法如果在编译期可知且运行期保持不变时即可将这个方法与所属的类型进行绑定这样一来由于明确了被调用的目标方法究竟是哪一个因此也就可以使用静态链接的方式将符号引用转换为直接引用晚期绑定如果被调用的方法在编译器无法被确定下来只能够在程序运行期根据实际的类型绑定相关的方法这种绑定方式就被称为晚期绑定虚方法和非虚方法如果方法在编译器就确定了具体的调用版本这个版本在运行时是不可变的这样的方法称为非虚方法比如静态方法私有方法方法实例构造器父类方法都是非虚方法其他方法称为虚方法虚方法表在面向对象编程中会频繁的使用到动态分派如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率为了提高性能采用在类的方法区建立一个虚方法表使用索引表来代替查找非虚方法不会出现在表中每个类中都有一个虚方法表表中存放着各个方法的实际入口虚方法表会在类加载的连接阶段被创建并开始初始化类的变量初始值准备完成之后会把该类的方法表也初始化完毕方法返回地址用来存放调用该方法的寄存器的值一个方法的结束有两种方式正常执行完成出现未处理的异常非正常退出无论通过哪种方式退出在方法退出后都返回到该方法被调用的位置方法正常退出时调用者的计数器的值作为返回地址即调用该方法的指令的下一条指令的地址而通过异常退出的返回地址是要通过异常表来确定的栈帧中一般不会保存这部分信息当一个方法开始执行后只有两种方式可以退出这个方法执行引擎遇到任意一个方法返回的字节码指令会有返回值传递给上层的方法调用者简称正常完成出口一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定在字节码指令中返回指令包含当返回值是和类型时使用以及另外还有一个指令供声明为的方法实例初始化方法类和接口的初始化方法使用在方法执行的过程中遇到了异常并且这个异常没有在方法内进行处理也就是只要在本方法的异常表中没有搜索到匹配的异常处理器就会导致方法退出简称异常完成出口方法执行过程中抛出异常时的异常处理存储在一个异常处理表方便在发生异常的时候找到处理异常的代码本质上方法的退出就是当前栈帧出栈的过程此时需要恢复上层方法的局部变量表操作数栈将返回值压入调用者栈帧的操作数栈设置寄存器值等让调用者方法继续执行下去正常完成出口和异常完成出口的区别在于通过异常完成出口退出的不会给他的上层调用者产生任何的返回值附加信息栈帧中还允许携带与虚拟机实现相关的一些附加信息例如对程序调试提供支持的信息但这些信息取决于具体的虚拟机实现三本地方法栈本地方法接口简单的讲一个就是一个调用非代码的接口我们知道的类就有很多本地方法为什么要使用本地方法使用起来非常方便然而有些层次的任务用实现起来也不容易或者我们对程序的效率很在意时问题就来了与环境外交互有时应用需要与外面的环境交互这就是本地方法存在的原因与操作系统交互支持语言本身和运行时库但是有时仍需要依赖一些底层系统的支持通过本地方法我们可以实现用与实现了的底层系统交互的一些部分就是语言写的的解释器就是实现的这使得它能像一些普通的一样与外部交互大部分都是用实现的它也通过一些本地方法与外界交互比如类的的方法是用实现的但它实现调用的是该类的本地方法该方法是实现的并被植入内部本地方法栈虚拟机栈用于管理方法的调用而本地方法栈用于管理本地方法的调用本地方法栈也是线程私有的允许线程固定或者可动态扩展的内存大小如果线程请求分配的栈容量超过本地方法栈允许的最大容量虚拟机将会抛出一个异常如果本地方法栈可以动态扩展并且在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的本地方法栈那么虚拟机将会抛出一个异常本地方法是使用语言实现的它的具体做法是中登记方法在执行时加载本地方法库当某个线程调用一个本地方法时它就进入了一个全新的并且不再受虚拟机限制的世界它和虚拟机拥有同样的权限本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存并不是所有都支持本地方法因为虚拟机规范并没有明确要求本地方法栈的使用语言具体实现方式数据结构等如果产品不打算支持方法也可以无需实现本地方法栈在中直接将本地方法栈和虚拟机栈合二为一栈是运行时的单位而堆是存储的单位栈解决程序的运行问题即程序如何执行或者说如何处理数据堆解决的是数据存储的问题即数据怎么放放在哪四堆内存内存划分对于大多数应用堆是虚拟机管理的内存中最大的一块被所有线程共享此内存区域的唯一目的就是存放对象实例几乎所有的对象实例以及数据都在这里分配内存为了进行高效的垃圾回收虚拟机把堆内存逻辑上划分成三块区域分代的唯一理由就是优化性能新生带年轻代新对象和没达到一定年龄的对象都在新生代老年代养老区被长时间使用的对象老年代的内存空间应该要比年轻代更大元空间之前叫永久代像一些方法中的操作临时对象等之前是占用内存之后直接使用物理内存虚拟机规范规定堆可以是处于物理上不连续的内存空间中只要逻辑上是连续的即可像磁盘空间一样实现时既可以是固定大小也可以是可扩展的主流虚拟机都是可扩展的通过和控制如果堆中没有完成实例分配并且堆无法再扩展时就会抛出异常年轻代年轻代是所有新对象创建的地方当填充年轻代时执行垃圾收集这种垃圾收集称为年轻一代被分为三个部分伊甸园和两个幸存区被称为或默认比例是大多数新创建的对象都位于内存空间中当空间被对象填充时执行并将所有幸存者对象移动到一个幸存者空间中检查幸存者对象并将它们移动到另一个幸存者空间所以每次一个幸存者空间总是空的经过多次循环后存活下来的对象被移动到老年代通常这是通过设置年轻一代对象的年龄阈值来实现的然后他们才有资格提升到老一代老年代旧的一代内存包含那些经过许多轮小型后仍然存活的对象通常垃圾收集是在老年代内存满时执行的老年代垃圾收集称为主通常需要更长的时间大对象直接进入老年代大对象是指需要大量连续内存空间的对象这样做的目的是避免在区和两个区之间发生大量的内存拷贝元空间不管是之前的永久代还是及以后的元空间都可以看作是虚拟机规范中方法区的实现虽然虚拟机规范把方法区描述为堆的一个逻辑部分但是它却有一个别名叫非堆目的应该是与堆区分开所以元空间放在后边的方法区再说设置堆内存大小和堆用于存储对象实例那么堆的大小在启动的时候就确定了我们可以通过和来设定用来表示堆的起始内存等价于用来表示堆的最大内存等价于如果堆的内存大小超过设定的最大内存就会抛出异常我们通常会将和两个参数配置为相同的值其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小从而提高性能默认情况下初始堆内存大小为电脑内存大小默认情况下最大堆内存大小为电脑内存大小可以通过代码获取到我们的设置值当然也可以模拟返回堆大小返回堆的最大内存系统内存大小系统内存大小查看堆内存分配在默认不配置堆内存大小的情况下根据默认值来配置当前内存大小默认情况下新生代和老年代的比例是可以通过来配置新生代中的的比例是可以通过来配置若在中开启了会动态调整堆中各个区域的大小以及进入老年代的年龄此时和将会失效而是默认开启在中不要随意关闭除非对堆内存的划分有明确的规划每次后都会重新计算的大小计算依据是过程中统计的时间吞吐量内存占用量进程号对象在堆中的生命周期在内存模型的堆中堆被划分为新生代和老年代新生代又被进一步划分为区和区区由和组成当创建一个对象时对象会被优先分配到新生代的区此时会给对象定义一个对象年轻计数器当空间不足时将执行新生代的垃圾回收会把存活的对象转移到中并且对象年龄对象在中同样也会经历每经历一次对象年龄都会如果分配的对象超过了对象会直接被分配到老年代对象的分配过程为对象分配内存是一件非常严谨和复杂的任务的设计者们不仅需要考虑内存如何分配在哪里分配等问题并且由于内存分配算法和内存回收算法密切相关所以还需要考虑执行完内存回收后是否会在内存空间中产生内存碎片的对象先放在伊甸园区此区有大小限制当伊甸园的空间填满时程序又需要创建对象的垃圾回收器将对伊甸园区进行垃圾回收将伊甸园区中的不再被其他对象所引用的对象进行销毁再加载新的对象放到伊甸园区然后将伊甸园中的剩余对象移动到幸存者区如果再次触发垃圾回收此时上次幸存下来的放到幸存者区如果没有回收就会放到幸存者区如果再次经历垃圾回收此时会重新放回幸存者区接着再去幸存者区什么时候才会去养老区呢默认是次回收标记在养老区相对悠闲当养老区内存不足时再次触发进行养老区的内存清理若养老区执行了之后发现依然无法进行对象的保存就会产生异常垃圾回收简介在进行时并非每次都对堆内存新生代老年代方法区区域一起回收的大部分时候回收的都是指新生代针对的实现它里面的按照回收区域又分为两大类部分收集整堆收集部分收集不是完整收集整个堆的垃圾收集其中又分为新生代收集只是新生代的垃圾收集老年代收集只是老年代的垃圾收集目前只有会有单独收集老年代的行为很多时候会和混合使用需要具体分辨是老年代回收还是整堆回收混合收集收集整个新生代以及部分老年代的垃圾收集目前只有会有这种行为整堆收集收集整个堆和方法区的垃圾什么是从内存模型而不是垃圾回收的角度对区域继续进行划分为每个线程分配了一个私有缓存区域它包含在空间内多线程同时分配内存时使用可以避免一系列的非线程安全问题同时还能提升内存分配的吞吐量因此我们可以将这种内存分配方式称为快速分配策略衍生出来的大都提供了设计为什么要有堆区是线程共享的任何线程都可以访问到堆区中的共享数据由于对象实例的创建在中非常频繁因此在并发环境下从堆区中划分内存空间是线程不安全的为避免多个线程操作同一地址需要使用加锁等机制进而影响分配速度尽管不是所有的对象实例都能够在中成功分配内存但确实是将作为内存分配的首选在程序中可以通过设置是否开启空间默认情况下空间的内存非常小仅占有整个空间的我们可以通过设置空间所占用空间的百分比大小一旦对象在空间分配内存失败时就会尝试着通过使用加锁机制确保数据操作的原子性从而直接在空间中分配内存堆是分配对象存储的唯一选择吗随着编译期的发展和逃逸分析技术的逐渐成熟栈上分配标量替换优化技术将会导致一些微妙的变化所有的对象都分配到堆上也渐渐变得不那么绝对了深入理解虚拟机逃逸分析逃逸分析是目前虚拟机中比较前沿的优化技术这是一种可以有效减少程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法通过逃逸分析编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上逃逸分析的基本行为就是分析对象动态作用域当一个对象在方法中被定义后对象只在方法内部使用则认为没有发生逃逸当一个对象在方法中被定义后它被外部方法所引用则认为发生逃逸例如作为调用参数传递到其他地方中称为方法逃逸例如是一个方法内部变量上述代码中直接将返回这样这个有可能被其他方法所改变这样它的作用域就不只是在方法内部虽然它是一个局部变量但是其逃逸到了方法外部甚至还有可能被外部线程访问到譬如赋值给类变量或可以在其他线程中访问的实例变量称为线程逃逸上述代码如果想要不逃出方法可以这样写不直接返回那么将不会逃逸出方法参数设置在版本之后中默认就已经开启了逃逸分析如果使用较早版本可以通过显式开启开发中使用局部变量就不要在方法外定义使用逃逸分析编译器可以对代码做优化栈上分配将堆分配转化为栈分配如果一个对象在子程序中被分配要使指向该对象的指针永远不会逃逸对象可能是栈分配的候选而不是堆分配同步省略如果一个对象被发现只能从一个线程被访问到那么对于这个对象的操作可以不考虑同步分离对象或标量替换有的对象可能不需要作为一个连续的内存结构存在也可以被访问到那么对象的部分或全部可以不存储在内存而存储在寄存器编译器在编译期间根据逃逸分析的结果发现如果一个对象并没有逃逸出方法的话就可能被优化成栈上分配分配完成后继续在调用栈内执行最后线程结束栈空间被回收局部变量对象也被回收这样就无需进行垃圾回收了常见栈上分配的场景成员变量赋值方法返回值实例引用传递代码优化之同步省略消除线程同步的代价是相当高的同步的后果是降低并发性和性能在动态编译同步块的时候编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程如果没有那么编译器在编译这个同步块的时候就会取消对这个代码的同步这样就能大大提高并发性和性能这个取消同步的过程就叫做同步省略也叫锁消除如上代码代码中对这个对象进行加锁但是对象的生命周期只在方法中并不会被其他线程所访问到所以在编译阶段就会被优化掉优化成代码优化之标量替换标量是指一个无法再分解成更小的数据的数据中的原始数据类型就是标量相对的那些的还可以分解的数据叫做聚合量中的对象就是聚合量因为其还可以分解成其他聚合量和标量在阶段通过逃逸分析确定该对象不会被外部访问并且对象可以被进一步分解时不会创建该对象而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替这些代替的成员变量在栈帧或寄存器上分配空间这个过程就是标量替换通过可以开启标量替换查看标量替换情况以上代码中对象并没有逃逸出方法并且对象是可以拆解成标量的那么就不会直接创建对象而是直接使用两个标量来替代对象代码优化之栈上分配我们通过内存分配可以知道中的对象都是在堆上进行分配当对象没有被引用的时候需要依靠进行回收内存如果对象数量较多的时候会给带来较大压力也间接影响了应用的性能为了减少临时对象在堆内分配的数量通过逃逸分析确定该对象不会被外部访问那就通过标量替换将该对象分解在栈上分配内存这样该对象所占用的内存空间就可以随栈帧出栈而销毁就减轻了垃圾回收的压力总结关于逃逸分析的论文在年就已经发表了但直到才有实现而且这项技术到如今也并不是十分成熟的其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗虽然经过逃逸分析可以做标量替换栈上分配和锁消除但是逃逸分析自身也是需要进行一系列复杂的分析的这其实也是一个相对耗时的过程一个极端的例子就是经过逃逸分析之后发现没有一个对象是不逃逸的那这个逃逸分析的过程就白白浪费掉了虽然这项技术并不十分成熟但是他也是即时编译器优化技术中一个十分重要的手段五方法区方法区与堆一样是所有线程共享的内存区域虽然虚拟机规范把方法区描述为堆的一个逻辑部分但是它却有一个别名叫非堆目的应该是与堆区分开运行时常量池是方法区的一部分文件中除了有类的版本字段方法接口等描述信息外还有一项信息是常量池用于存放编译期生成的各种字面量和符号引用这部分内容将类在加载后进入方法区的运行时常量池中存放运行期间也可能将新的常量放入池中这种特性被开发人员利用得比较多的是方法受方法区内存的限制当常量池无法再申请到内存时会抛出异常方法区的大小和堆空间一样可以选择固定大小也可选择可扩展方法区的大小决定了系统可以放多少个类如果系统类太多导致方法区溢出虚拟机同样会抛出内存溢出错误关闭后方法区即被释放解惑你是否也有看不同的参考资料有的内存结构图有方法区有的又是永久代元数据区一脸懵逼的时候方法区只是规范中定义的一个概念用于存储类信息常量池静态变量编译后的代码等数据并没有规定如何去实现它不同的厂商有不同的实现而永久代是虚拟机特有的概念的时候又被元空间取代了永久代和元空间都可以理解为方法区的落地实现永久代物理是堆的一部分和新生代老年代地址是连续的受垃圾回收器管理而元空间存在于本地内存我们常说的堆外内存不受垃圾回收器管理这样就不受限制了也比较难发生都会有溢出异常中我们通过和来设置永久代参数之后随着永久代的取消这些参数也就随之失效了改为通过和用来设置元空间参数存储内容不同元空间存储类的元信息静态变量和常量池等并入堆中相当于永久代的数据被分到了堆和元空间中如果方法区域中的内存不能用于满足分配请求则虚拟机抛出规范说方法区在逻辑上是堆的一部分但目前实际上是与堆分开的所以对于方法区之后的变化移除了永久代替换为元空间永久代中的转移到了本地内存而不是虚拟机永久代中的和转移到了永久代参数元空间参数设置方法区内存的大小及以后元数据区大小可以使用参数和指定替代上述原有的两个参数默认值依赖于平台下是的值是即没有限制与永久代不同如果不指定大小默认情况下虚拟机会耗尽所有的可用系统内存如果元数据发生溢出虚拟机一样会抛出异常设置初始的元空间大小对于一个位的服务器端来说其默认的的值为这就是初始的高水位线一旦触及这个水位线将会被触发并卸载没用的类即这些类对应的类加载器不再存活然后这个高水位线将会重置新的高水位线的值取决于后释放了多少元空间如果释放的空间不足那么在不超过时适当提高该值如果释放空间过多则适当降低该值如果初始化的高水位线设置过低上述高水位线调整情况会发生很多次通过垃圾回收的日志可观察到多次调用为了避免频繁建议将设置为一个相对较高的值方法区内部结构方法区用于存储已被虚拟机加载的类型信息常量静态变量即时编译器编译后的代码缓存等类型信息对每个加载的类型类接口枚举注解必须在方法区中存储以下类型信息这个类型的完整有效名称全名包名类名这个类型直接父类的完整有效名对于或是都没有父类这个类型的修饰符的某个子集这个类型直接接口的一个有序列表域信息必须在方法区中保存类型的所有域的相关信息以及域的声明顺序域的相关信息包括域名称域类型域修饰符的某个子集方法信息必须保存所有方法的方法名称方法的返回类型方法参数的数量和类型方法的修饰符的一个子集方法的字符码操作数栈局部变量表及大小和方法除外异常表和方法除外每个异常处理的开始位置结束位置代码处理在程序计数器中的偏移地址被捕获的异常类的常量池索引栈堆方法区的交互关系运行时常量池运行时常量池是方法区的一部分理解运行时常量池的话我们先来说说字节码文件文件中的常量池常量池表常量池一个有效的字节码文件中除了包含类的版本信息字段方法以及接口等描述信息外还包含一项信息那就是常量池表包含各种字面量和对类型域和方法的符号引用为什么需要常量池一个源文件中的类接口编译后产生一个字节码文件而中的字节码需要数据支持通常这种数据会很大以至于不能直接存到字节码里换另一种方式可以存到常量池这个字节码包含了指向常量池的引用在动态链接的时候用到的就是运行时常量池如下我们通过查看一个只有方法的简单类字节码中的指向的就是常量池可以看作是一张表虚拟机指令根据这张常量表找到要执行的类名方法名参数类型字面量等类型运行时常量池在加载类和结构到虚拟机后就会创建对应的运行时常量池常量池表是文件的一部分用于存储编译期生成的各种字面量和符号引用这部分内容将在类加载后存放到方法区的运行时常量池中为每个已加载的类型类或接口都维护一个常量池池中的数据项像数组项一样是通过索引访问的运行时常量池中包含各种不同的常量包括编译器就已经明确的数值字面量也包括到运行期解析后才能够获得的方法或字段引用此时不再是常量池中的符号地址了这里换为真实地址运行时常量池相对于文件常量池的另一个重要特征是动态性语言并不要求常量一定只有编译期间才能产生运行期间也可以将新的常量放入池中类的方法就是这样的当创建类或接口的运行时常量池时如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值则会抛出异常方法区在中的演进细节只有才有永久代的概念及之前有永久代静态变量存放在永久代上有永久代但已经逐步去永久代字符串常量池静态变量移除保存在堆中及之后取消永久代类型信息字段方法常量保存在本地内存的元空间但字符串常量池静态变量仍在堆中中字符串常量池保存哪里永久代方法区还是堆区运行时常量池是虚拟机规范中是方法区的一部分在加载类和结构到虚拟机后就会创建对应的运行时常量池而字符串常量池是这个过程中常量字符串的存放位置所以从这个角度字符串常量池属于虚拟机规范中的方法区它是一个逻辑上的概念而堆区永久代以及元空间是实际的存放位置不同的虚拟机对虚拟机的规范比如方法区是不一样的只有才有永久代的概念也是发展的由于一些问题在新窗口打开的存在考虑逐渐去永久代对于不同版本的实际的存储位置是有差异的具体看如下表格版本是否有永久代字符串常量池放在哪里方法区逻辑上规范由哪些实际的部分实现的及之前有永久代运行时常量池包括字符串常量池静态变量存放在永久代上这个时期方法区在中是由永久代来实现的以至于这个时期说方法区就是指永久代有永久代但已经逐步去永久代字符串常量池静态变量移除保存在堆中这个时期方法区在中由永久代类型信息字段方法常量和堆字符串常量池静态变量共同实现及之后取消永久代类型信息字段方法常量保存在本地内存的元空间但字符串常量池静态变量仍在堆中这个时期方法区在中由本地内存的元空间类型信息字段方法常量和堆字符串常量池静态变量共同实现移除永久代原因为永久代设置空间大小是很难确定的在某些场景下如果动态加载类过多容易产生区的如果某个实际工程中因为功能点比较多在运行过程中要不断动态加载很多类经常出现而元空间和永久代最大的区别在于元空间不在虚拟机中而是使用本地内存所以默认情况下元空间的大小仅受本地内存限制对永久代进行调优较困难方法区的垃圾回收方法区的垃圾收集主要回收两部分内容常量池中废弃的常量和不再使用的类型先来说说方法区内常量池之中主要存放的两大类常量字面量和符号引用字面量比较接近语言层次的常量概念如文本字符串被声明为的常量值等而符号引用则属于编译原理方面的概念包括下面三类常量类和接口的全限定名字段的名称和描述符方法的名称和描述符虚拟机对常量池的回收策略是很明确的只要常量池中的常量没有被任何地方引用就可以被回收判定一个类型是否属于不再被使用的类需要同时满足三个条件该类所有的实例都已经被回收也就是堆中不存在该类及其任何派生子类的实例加载该类的类加载器已经被回收这个条件除非是经过精心设计的可替换类加载器的场景如的重加载等否则通常很难达成该类对应的对象没有在任何地方被引用无法在任何地方通过反射访问该类的方法虚拟机被允许堆满足上述三个条件的无用类进行回收这里说的仅仅是被允许而并不是和对象一样不使用了就必然会回收是否对类进行回收虚拟机提供了参数进行控制还可以使用以及查看类加载和卸载信息在大量使用反射动态代理等框架动态生成以及这类频繁自定义的场景都需要虚拟机具备类卸载的功能以保证永久代不会溢出参考与感谢作者海星来源于原作者参考内容如下算是一篇学习笔记共勉主要来源深入理解虚拟机第三版宋红康老师的教程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-12-26 17:06:46",postMainColor:""}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:(e,t,a)=>{if(0===a)return;const o={value:t,expiry:Date.now()+864e5*a};localStorage.setItem(e,JSON.stringify(o))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const a=JSON.parse(t);if(!(Date.now()>a.expiry))return a.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((a,o)=>{const c=document.createElement("script");c.src=e,c.async=!0,c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},Object.keys(t).forEach((e=>{c.setAttribute(e,t[e])})),document.head.appendChild(c)})),e.getCSS=(e,t=!1)=>new Promise(((a,o)=>{const c=document.createElement("link");c.rel="stylesheet",c.href=e,t&&(c.id=t),c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},document.head.appendChild(c)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#18171d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#f7f9fe")};const t=saveToLocal.get("theme"),a=window.matchMedia("(prefers-color-scheme: dark)").matches,o=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!a&&!o&&!c;if(void 0===t){if(o)activateLightMode();else if(a)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:yellow;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="AlphaDog" type="application/atom+xml"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/avatar.png"><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),setTimeout((function(){preloader.endLoading()}),1e4),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://npm.elemecdn.com/pace-js@latest/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="博客"><img class="back-menu-item-icon" src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jp-blog-favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">关于</div><div class="back-menu-list"><a class="back-menu-item" href="/about/" title="关于作者"><img class="back-menu-item-icon" src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/avatar.png" alt="关于作者"><span class="back-menu-item-text">关于作者</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">AlphaDog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>分享</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size:.9em"></i> <span>番剧分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/books/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size:.9em"></i> <span>读书分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i> <span>电影分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/games/"><i class="anzhiyufont anzhiyu-icon-dice faa-tada" style="font-size:.9em"></i> <span>游戏分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/songs/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>音乐分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size:.9em"></i> <span>好物分享</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i> <span>友情链接</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size:.9em"></i> <span>博客快讯</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fishpound/"><i class="anzhiyufont anzhiyu-icon-fish faa-tada" style="font-size:.9em"></i> <span>博客鱼塘</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i> <span>关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i> <span>网站公告</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i> <span>随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i> <span>搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%812.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%812.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%812.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%812.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url">技术分享</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> Java</span></a><a class="article-meta__tags" href="/tags/JVM/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> JVM</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JVM系列-JVM内存结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-12-06T08:58:18.000Z" title="发表于 2024-12-06 16:58:18">2024-12-06</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-26T09:06:46.000Z" title="更新于 2024-12-26 17:06:46">2024-12-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">14.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" data-flag-title="JVM系列-JVM内存结构"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/article/135490ad.html#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-cover.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://www.junpengzhou.top/article/135490ad.html"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url">技术分享</a><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><a href="/tags/JVM/" tabindex="-1" itemprop="url">JVM</a><h1 id="CrawlerTitle" itemprop="name headline">JVM系列-JVM内存结构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Junpengzhou</span><time itemprop="dateCreated datePublished" datetime="2024-12-06T08:58:18.000Z" title="发表于 2024-12-06 16:58:18">2024-12-06</time><time itemprop="dateCreated datePublished" datetime="2024-12-26T09:06:46.000Z" title="更新于 2024-12-26 17:06:46">2024-12-26</time></header><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/007S8ZIlly1gg9kuge8ovj32150tt7cd.jpg" alt="img"></p><h2 id="运行时数据区">运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt="jvm-framework"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li><li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）</li></ul><h2 id="一程序计数器">一、程序计数器</h2><p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p><h3 id="11-作用">1.1 作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/0082zybply1gc5kmznm1sj31m50u0wph.jpg" alt="jvm-pc-counter"></p><p>（分析：进入class文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的Code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。）</p><h3 id="12-概述">1.2 概述</h3><p>通过下面两个问题，理解下PC计数器</p><ul><li><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></li></ul><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><ul><li><strong>PC寄存器为什么会被设定为线程私有的？</strong></li></ul><p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p><p>相关总结如下：</p><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 Native 方法，则是未指定值（undefined）</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li></ul><h2 id="二虚拟机栈">二、虚拟机栈</h2><h3 id="21-概述">2.1 概述</h3><blockquote><p>Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p></blockquote><p><strong>作用</strong>：主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><p><strong>特点</strong>：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><p>官方提供的参考工具，可查一些参数和操作：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BGBCIEFC">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BGBCIEFC</a></p><h3 id="22-栈的存储单位">2.2 栈的存储单位</h3><p>栈中存储什么？</p><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li><li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h3 id="23-栈运行原理">2.3 栈运行原理</h3><ul><li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出/后进先出”原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li></ul><p>IDEA 在 debug 时候，可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/0082zybply1gc9lezaxrbj319v0u0k4w.jpg" alt="img"></p><h3 id="24-栈帧的内部结构">2.4 栈帧的内部结构</h3><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（Operand Stack）(或称为表达式栈)</p></li><li><p>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</p></li><li><p>方法返回地址（Return Address）：方法正常退出或异常退出的地址</p></li><li><p>一些附加信息</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt="jvm-stack-frame"></p></li></ul><p>继续深抛栈帧中的五部分~~</p><h4 id="241-局部变量表">2.4.1. 局部变量表</h4><ul><li>局部变量表也被称为局部变量数组或者本地变量表</li><li>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li></ul><h5 id="槽-slot">槽 Slot</h5><ul><li><p>局部变量表最基本的存储单元是 Slot（变量槽）</p></li><li><p>在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot</p><ul><li>byte、short、char 在存储前被转换为int，boolean也被转换为int，0 表示 false，非 0 表示 true</li><li>long 和 double 则占据两个 Slot</li></ul></li><li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上</p></li><li><p><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</p></li><li><p>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为this 变量不存在于当前方法的局部变量表中）</p></li><li><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/0082zybply1gc9s12g5wlj31li0owdm9.jpg" alt="img"></p></li><li><p>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</p></li><li><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p></li></ul><h4 id="242-操作数栈">2.4.2. 操作数栈</h4><ul><li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li></ul><h5 id="概述">概述</h5><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</li><li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h5 id="栈顶缓存top-of-stack-cashing">栈顶缓存（Top-of-stack-Cashing）</h5><p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读/写速度非常迅速，甚至可以比内存的读/写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong></p><h4 id="243-动态链接指向运行时常量池的方法引用">2.4.3. 动态链接（指向运行时常量池的方法引用）</h4><ul><li><p><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。</p></li><li><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/0082zybply1gca4k4gndgj31d20o2td0.jpg" alt="jvm-dynamic-linking"></p></li></ul><h5 id="jvm-是如何执行方法调用的">JVM 是如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><blockquote><p>【这一块内容，除了方法调用，还包括解析、分派（静态分派、动态分派、单分派与多分派），这里先不介绍，后续再挖】</p></blockquote><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p><ul><li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li></ul><h5 id="虚方法和非虚方法">虚方法和非虚方法</h5><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>其他方法称为虚方法</li></ul><h5 id="虚方法表">虚方法表</h5><p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><h4 id="244-方法返回地址return-address">2.4.4. 方法返回地址（return address）</h4><p>用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol type="1"><li><p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong></p><p>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</p><p>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</p></li><li><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong></p><p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p></li></ol><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p><h4 id="245-附加信息">2.4.5. 附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p><hr><h2 id="三本地方法栈">三、本地方法栈</h2><h3 id="31-本地方法接口native-method-interface">3.1 本地方法接口（Native Method Interface）</h3><p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><blockquote><p>为什么要使用本地方法（Native Method）?</p></blockquote><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li><li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li><li>Sun's Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是C实现的，并被植入 JVM 内部。</li></ul><h3 id="32-本地方法栈native-method-stack">3.2 本地方法栈（Native Method Stack）</h3><ul><li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈也是线程私有的</li><li>允许线程固定或者可动态扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li></ul></li><li>本地方法是使用 C 语言实现的</li><li>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li><li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li><li>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</li></ul><hr><blockquote><p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><h2 id="四堆内存">四、堆内存</h2><h3 id="41-内存划分">4.1 内存划分</h3><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ul><li><p>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</p></li><li><p>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</p></li><li><p>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" alt="JDK7"></p></li></ul><p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p><h4 id="年轻代-young-generation">年轻代 (Young Generation)</h4><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p><ul><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ul><h4 id="老年代old-generation">老年代(Old Generation)</h4><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" alt="img"></p><h4 id="元空间">元空间</h4><p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p><p>所以元空间放在后边的方法区再说。</p><h3 id="42-设置堆内存大小和-oom">4.2 设置堆内存大小和 OOM</h3><p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 <code>-Xmx</code> 和 <code>-Xms</code> 来设定</p><ul><li><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></li></ul><p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p><p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p><ul><li>默认情况下，初始堆内存大小为：电脑内存大小/64</li><li>默认情况下，最大堆内存大小为：电脑内存大小/4</li></ul><p>可以通过代码获取到我们的设置值，当然也可以模拟 OOM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回 JVM 堆大小</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">initalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line">  <span class="comment">//返回 JVM 堆的最大内存</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"-Xms : "</span>+initalMemory + <span class="string">"M"</span>);</span><br><span class="line">  System.out.println(<span class="string">"-Xmx : "</span>+maxMemory + <span class="string">"M"</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"系统内存大小："</span> + initalMemory * <span class="number">64</span> / <span class="number">1024</span> + <span class="string">"G"</span>);</span><br><span class="line">  System.out.println(<span class="string">"系统内存大小："</span> + maxMemory * <span class="number">4</span> / <span class="number">1024</span> + <span class="string">"G"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="查看-jvm-堆内存分配">查看 JVM 堆内存分配</h4><ol type="1"><li><p>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</p></li><li><p>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置</p><ul><li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li></ul></li><li><p>若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄</p><p>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code> 将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code></p><p>在 JDK 8中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</p></li></ol><p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小</p><p>计算依据是<strong>GC过程</strong>中统计的<strong>GC时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   {product}</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            {product}</span><br><span class="line">    uintx InitialHeapSize                          := 134217728                           {product}</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           {product}</span><br><span class="line">    uintx MaxHeapSize                              := 2147483648                          {product}</span><br><span class="line">java version "1.8.0_211"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br><span class="line">$ jmap -heap 进程号</span><br></pre></td></tr></table></figure><h3 id="43-对象在堆中的生命周期">4.3 对象在堆中的生命周期</h3><ol type="1"><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代<ul><li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区<ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）<ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h3 id="44-对象的分配过程">4.4 对象的分配过程</h3><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol type="1"><li>new 的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h3 id="45-gc-垃圾回收简介">4.5 GC 垃圾回收简介</h3><h4 id="minor-gcmajor-gcfull-gc">Minor GC、Major GC、Full GC</h4><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul><li>目前只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h3 id="46-tlab">4.6 TLAB</h3><h4 id="什么是-tlab-thread-local-allocation-buffer">什么是 TLAB （Thread Local Allocation Buffer）?</h4><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li><li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li></ul><h4 id="为什么要有-tlab-">为什么要有 TLAB ?</h4><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h3 id="47-堆是分配对象存储的唯一选择吗">4.7 堆是分配对象存储的唯一选择吗</h3><blockquote><p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 ——《深入理解 Java 虚拟机》</p></blockquote><h4 id="逃逸分析">逃逸分析</h4><p><strong>逃逸分析(Escape Analysis)是目前 Java 虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">   <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将sb返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>上述代码如果想要 <code>StringBuffer sb</code>不逃出方法，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">   <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p><p><strong>参数设置：</strong></p><ul><li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li><li>如果使用较早版本，可以通过<code>-XX"+DoEscapeAnalysis</code>显式开启</li></ul><p>开发中使用局部变量，就不要在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做优化：</p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li></ul><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p><h5 id="代码优化之同步省略消除">代码优化之同步省略（消除）</h5><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li><li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">synchronized</span>(keeper) {</span><br><span class="line">    System.out.println(keeper);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如上代码，代码中对 keeper 这个对象进行加锁，但是 keeper 对象的生命周期只在 <code>keep()</code>方法中，并不会被其他线程所访问到，所以在 JIT编译阶段就会被优化掉。优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  System.out.println(keeper);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="代码优化之标量替换">代码优化之标量替换</h5><p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p><p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">   alloc();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">   <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>（<span class="number">1</span>,<span class="number">2</span>）;</span><br><span class="line">   System.out.println(<span class="string">"point.x="</span>+point.x+<span class="string">"; point.y="</span>+point.y);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上代码中，point 对象并没有逃逸出 <code>alloc()</code> 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">   System.out.println(<span class="string">"point.x="</span>+x+<span class="string">"; point.y="</span>+y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="代码优化之栈上分配">代码优化之栈上分配</h5><p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><p><strong>总结：</strong></p><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><hr><h2 id="五方法区">五、方法区</h2><ul><li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryErro</code>r 异常。</li><li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li><li>JVM 关闭后方法区即被释放</li></ul><h3 id="51-解惑">5.1 解惑</h3><p>你是否也有看不同的参考资料，有的内存结构图有方法区，有的又是永久代，元数据区，一脸懵逼的时候？</p><ul><li><strong>方法区（method area）只是JVM 规范中定义的一个概念</strong>，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）是 Hotspot虚拟机特有的概念， Java8 的时候又被元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li><li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）</li><li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li><li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li><li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li></ul><p>所以对于方法区，Java8 之后的变化：</p><ul><li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul><h3 id="52-设置方法区内存的大小">5.2 设置方法区内存的大小</h3><p>JDK8 及以后：</p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li><li>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是 21M，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li></ul><h3 id="53-方法区内部结构">5.3 方法区内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><h4 id="类型信息">类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h4 id="域field信息">域（Field）信息</h4><ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul><h4 id="方法method信息">方法（Method）信息</h4><p>JVM 必须保存所有方法的</p><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）</li><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li><li>栈、堆、方法区的交互关系</li></ul><h3 id="54-运行时常量池">5.4 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><h4 id="常量池">常量池</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><h5 id="为什么需要常量池">为什么需要常量池？</h5><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/007S8ZIlly1gg9i91ze2gj320i0riahe.jpg" alt="img"></p><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池">运行时常量池</h4><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址</li><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><h3 id="55-方法区在-jdk678中的演进细节">5.5 方法区在 JDK6、7、8中的演进细节</h3><p>只有 HotSpot 才有永久代的概念</p><table><thead><tr class="header"><th>jdk1.6及之前</th><th>有永久代，静态变量存放在永久代上</th></tr></thead><tbody><tr class="odd"><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr class="even"><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td></tr></tbody></table><ul><li><strong>HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区</strong>？</li></ul><ol type="1"><li>运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个<strong>逻辑上的概念</strong>；而堆区，永久代以及元空间是实际的存放位置。</li><li>不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。</li><li>HotSpot也是发展的，由于<a target="_blank" rel="noopener external nofollow noreferrer" href="http://openjdk.java.net/jeps/122">一些问题在新窗口打开</a>的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，**实际的存储位置**是有差异的，具体看如下表格：</li></ol><table><thead><tr class="header"><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr class="odd"><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr class="even"><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr class="odd"><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table><h4 id="移除永久代原因">移除永久代原因</h4><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/007S8ZIlly1gg04ve34c2j30z00u0dp7.jpg" alt="img"></p><ul><li><p>为永久代设置空间大小是很难确定的。</p><p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</p></li><li><p>对永久代进行调优较困难</p></li></ul><h3 id="56-方法区的垃圾回收">5.6 方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code> 、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="参考与感谢">参考与感谢</h2><ul><li>作者：海星</li><li>来源于：JavaKeeper</li></ul><p>原作者参考内容如下</p><p>算是一篇学习笔记，共勉，主要来源：</p><p>《深入理解 Java 虚拟机 第三版》</p><p>宋红康老师的 JVM 教程</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/wicfhwffg/p/9382677.html">https://www.cnblogs.com/wicfhwffg/p/9382677.html</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/hollischuang/p/12501950.html">https://www.cnblogs.com/hollischuang/p/12501950.html</a></p></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Junpengzhou</div><div class="post-copyright__author_desc">Junpengzhou's Blog, Welcome!</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.junpengzhou.top/article/135490ad.html">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://www.junpengzhou.top/article/135490ad.html")'>JVM系列-JVM内存结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%812.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%812.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%812.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%812.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display:none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.junpengzhou.top/article/135490ad.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JVM系列-JVM内存结构&amp;url=https://www.junpengzhou.top/article/135490ad.html&amp;pic=https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-cover.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.junpengzhou.top" target="_blank">AlphaDog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> Java<span class="tagsPageCount">14</span></a><a class="post-meta__box__tags" href="/tags/JVM/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> JVM<span class="tagsPageCount">9</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/7bed74c2.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80-cover.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM系列-Java垃圾回收基础知识</div></div></a></div><div class="next-post pull-right"><a href="/article/ee36a0f3.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E7%94%B5%E5%8A%A8%E8%BD%A6%E9%AA%91%E8%A1%8C%E8%83%8C%E6%99%AF-cover.png?_r_=691d2978-3f7e-d4a9-598e-60a3ca9cf651" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM系列-JVM类加载机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/article/c95d1159.html" title="JVM系列-1-字节码详解"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E5%A4%8F%E6%97%A5%E8%8D%B7%E5%8F%B6%E4%B8%8B%E6%BD%9C%E6%B0%B4-cover.webp?_r_=ffe8bbc7-a436-5bb7-4c9d-6eb38004e9c0" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-12</div><div class="title">JVM系列-1-字节码详解</div></div></a></div><div><a href="/article/af15a4c5.html" title="JVM系列-CMS垃圾回收详解"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E7%94%B5%E5%8A%A8%E8%BD%A6%E9%AA%91%E8%A1%8C%E8%83%8C%E6%99%AF-cover.png?_r_=0b59f32c-e4c8-a228-9906-136372983eb2" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-06</div><div class="title">JVM系列-CMS垃圾回收详解</div></div></a></div><div><a href="/article/69762356.html" title="JVM系列-G1垃圾回收"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E6%B2%B3%E7%95%94%E7%9A%84%E9%83%81%E9%87%91%E9%A6%99-cover.webp?_r_=2d77c6bd-58a1-d52a-03c0-4e6d665f69da" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-06</div><div class="title">JVM系列-G1垃圾回收</div></div></a></div><div><a href="/article/5ecbd257.html" title="JVM系列-Java内存模型详解"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E5%A4%8F%E6%97%A5%E8%8D%B7%E5%8F%B6%E4%B8%8B%E6%BD%9C%E6%B0%B4-cover.webp?_r_=8ca74799-56c2-eca6-60f7-ed1a80dff0cf" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-06</div><div class="title">JVM系列-Java内存模型详解</div></div></a></div><div><a href="/article/ee36a0f3.html" title="JVM系列-JVM类加载机制"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E7%94%B5%E5%8A%A8%E8%BD%A6%E9%AA%91%E8%A1%8C%E8%83%8C%E6%99%AF-cover.png?_r_=691d2978-3f7e-d4a9-598e-60a3ca9cf651" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-06</div><div class="title">JVM系列-JVM类加载机制</div></div></a></div><div><a href="/article/7bed74c2.html" title="JVM系列-Java垃圾回收基础知识"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80-cover.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-06</div><div class="title">JVM系列-Java垃圾回收基础知识</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i> <span>评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" rel="external nofollow noreferrer" style="display:none">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-status"><img class="g-status" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"></div></div><div class="author-info__description">Useful, interesting, and meaningful</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Junpengzhou</h1><div class="author-info__desc">Junpengzhou's Blog, Welcome!</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/19265913" rel="external nofollow noreferrer" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="social-icon faa-parent animated-hover" href="mailto:jeepzhou11@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><a class="social-icon faa-parent animated-hover" href="https://mars.nasa.gov/participate/send-your-name/future/certificate/751767460870" rel="external nofollow noreferrer" target="_blank" title="NASA"><i class="anzhiyufont anzhiyu-icon-rocket"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-text">运行时数据区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">一、程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BD%9C%E7%94%A8"><span class="toc-text">1.1 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.2 概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">二、虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="toc-text">2.2 栈的存储单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">2.3 栈运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2.4 栈帧的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#241-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">2.4.1. 局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A7%BD-slot"><span class="toc-text">槽 Slot</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#242-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-text">2.4.2. 操作数栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98top-of-stack-cashing"><span class="toc-text">栈顶缓存（Top-of-stack-Cashing）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#243-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%8C%87%E5%90%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">2.4.3. 动态链接（指向运行时常量池的方法引用）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jvm-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84"><span class="toc-text">JVM 是如何执行方法调用的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">虚方法和非虚方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-text">虚方法表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#244-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80return-address"><span class="toc-text">2.4.4. 方法返回地址（return address）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#245-%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-text">2.4.5. 附加信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">三、本地方法栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3native-method-interface"><span class="toc-text">3.1 本地方法接口（Native Method Interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88native-method-stack"><span class="toc-text">3.2 本地方法栈（Native Method Stack）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">四、堆内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-text">4.1 内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3-young-generation"><span class="toc-text">年轻代 (Young Generation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3old-generation"><span class="toc-text">老年代(Old Generation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-text">元空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%92%8C-oom"><span class="toc-text">4.2 设置堆内存大小和 OOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-jvm-%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">查看 JVM 堆内存分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4.3 对象在堆中的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">4.4 对象的分配过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B"><span class="toc-text">4.5 GC 垃圾回收简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#minor-gcmajor-gcfull-gc"><span class="toc-text">Minor GC、Major GC、Full GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-tlab"><span class="toc-text">4.6 TLAB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-tlab-thread-local-allocation-buffer"><span class="toc-text">什么是 TLAB （Thread Local Allocation Buffer）?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-tlab-"><span class="toc-text">为什么要有 TLAB ?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97"><span class="toc-text">4.7 堆是分配对象存储的唯一选择吗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5%E6%B6%88%E9%99%A4"><span class="toc-text">代码优化之同步省略（消除）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">代码优化之标量替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-text">代码优化之栈上分配</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">五、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E8%A7%A3%E6%83%91"><span class="toc-text">5.1 解惑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">5.2 设置方法区内存的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">5.3 方法区内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9Ffield%E4%BF%A1%E6%81%AF"><span class="toc-text">域（Field）信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95method%E4%BF%A1%E6%81%AF"><span class="toc-text">方法（Method）信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">5.4 运行时常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">为什么需要常量池？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8-jdk678%E4%B8%AD%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="toc-text">5.5 方法区在 JDK6、7、8中的演进细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%8E%9F%E5%9B%A0"><span class="toc-text">移除永久代原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">5.6 方法区的垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">参考与感谢</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/5177e26d.html" title="四象限法则时间管理法（Eeisenhower Matrix）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-cover.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="四象限法则时间管理法（Eeisenhower Matrix）"></a><div class="content"><a class="title" href="/article/5177e26d.html" title="四象限法则时间管理法（Eeisenhower Matrix）">四象限法则时间管理法（Eeisenhower Matrix）</a><time datetime="2024-12-24T03:46:13.000Z" title="发表于 2024-12-24 11:46:13">2024-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/d0ee7058.html" title="响应式编程与异步编程和多线程编程的关系"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E7%94%B5%E5%8A%A8%E8%BD%A6%E9%AA%91%E8%A1%8C%E8%83%8C%E6%99%AF-cover.png?_r_=4493f91f-8114-6dc8-a2c5-5e61bf20fb22" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="响应式编程与异步编程和多线程编程的关系"></a><div class="content"><a class="title" href="/article/d0ee7058.html" title="响应式编程与异步编程和多线程编程的关系">响应式编程与异步编程和多线程编程的关系</a><time datetime="2024-12-17T08:25:38.000Z" title="发表于 2024-12-17 16:25:38">2024-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/34ed37b6.html" title="Spring Reactor实战之Mono与Flux"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E7%BA%BF%E6%9D%A1%E5%B0%8F%E7%8B%97-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring Reactor实战之Mono与Flux"></a><div class="content"><a class="title" href="/article/34ed37b6.html" title="Spring Reactor实战之Mono与Flux">Spring Reactor实战之Mono与Flux</a><time datetime="2024-12-17T07:33:24.000Z" title="发表于 2024-12-17 15:33:24">2024-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/35b1d86e.html" title="Spring5+的WebClient使用指南"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/spring%E7%87%95%E5%AD%90-cover.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring5+的WebClient使用指南"></a><div class="content"><a class="title" href="/article/35b1d86e.html" title="Spring5+的WebClient使用指南">Spring5+的WebClient使用指南</a><time datetime="2024-12-11T06:29:31.000Z" title="发表于 2024-12-11 14:29:31">2024-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/af15a4c5.html" title="JVM系列-CMS垃圾回收详解"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/%E7%94%B5%E5%8A%A8%E8%BD%A6%E9%AA%91%E8%A1%8C%E8%83%8C%E6%99%AF-cover.png?_r_=0b59f32c-e4c8-a228-9906-136372983eb2" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="JVM系列-CMS垃圾回收详解"></a><div class="content"><a class="title" href="/article/af15a4c5.html" title="JVM系列-CMS垃圾回收详解">JVM系列-CMS垃圾回收详解</a><time datetime="2024-12-06T09:07:10.000Z" title="发表于 2024-12-06 17:07:10">2024-12-06</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:jeepzhou11@163.com" rel="external nofollow noreferrer" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://weibo.com/u/5441665984" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/avatar.png" size="50px"><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/junpengzhou" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://space.bilibili.com/19265913" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div class="copyright">&copy;2020 - 2025 By Junpengzhou</div><div class="footer_custom_text">学习是一种信仰，分享是一种快乐！</div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener external nofollow noreferrer" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">虫洞</div><div class="footer-links"><a class="footer-item" title="了解虫洞" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.foreverblog.cn/notice/16.html">了解虫洞</a><a class="footer-item" title="穿梭虫洞" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.foreverblog.cn/go.html">穿梭虫洞</a><a class="footer-item" title="虫洞中文网" target="_blank" rel="noopener external nofollow noreferrer" href="https://wormholechn.medium.com/">虫洞中文网</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" rel="external nofollow noreferrer" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站由Hexo驱动" title="本站由Hexo驱动"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt="本站由Hexo驱动"></a><a class="github-badge" target="_blank" href="https://about.gitlab.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站项目由Gitlab托管" title="本站项目由Gitlab托管"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Gitlab-blue?style=flat&amp;logo=gitlab" alt="本站项目由Gitlab托管"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a><a class="github-badge" target="_blank" href="https://www.foreverblog.cn/go.html" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="穿梭虫洞-随机访问十年之约友链博客" title="穿梭虫洞-随机访问十年之约友链博客"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.foreverblog.cn/wormhole_4_tp.gif" alt="穿梭虫洞-随机访问十年之约友链博客"></a></p></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="博客"><img class="back-menu-item-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/jp-blog-favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">关于</div><div class="back-menu-list"><a class="back-menu-item" href="/about/" title="关于作者"><img class="back-menu-item-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://junpengzhou-1305658609.cos.ap-nanjing.myqcloud.com/blog/avatar.png" alt="关于作者"><span class="back-menu-item-text">关于作者</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>分享</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size:.9em"></i> <span>番剧分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/books/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size:.9em"></i> <span>读书分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i> <span>电影分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/games/"><i class="anzhiyufont anzhiyu-icon-dice faa-tada" style="font-size:.9em"></i> <span>游戏分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/songs/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>音乐分享</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size:.9em"></i> <span>好物分享</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i> <span>友情链接</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size:.9em"></i> <span>博客快讯</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fishpound/"><i class="anzhiyufont anzhiyu-icon-fish faa-tada" style="font-size:.9em"></i> <span>博客鱼塘</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i> <span>关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i> <span>网站公告</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i> <span>随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Excel%E6%8A%80%E5%B7%A7/" style="font-size:.88rem">Excel技巧<sup>1</sup></a><a href="/tags/JVM/" style="font-size:.88rem">JVM<sup>9</sup></a><a href="/tags/Java/" style="font-size:.88rem">Java<sup>14</sup></a><a href="/tags/Markdown/" style="font-size:.88rem">Markdown<sup>1</sup></a><a href="/tags/Spring/" style="font-size:.88rem">Spring<sup>2</sup></a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size:.88rem">中间件<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" style="font-size:.88rem">前端技术<sup>1</sup></a><a href="/tags/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/" style="font-size:.88rem">建站经验<sup>7</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">操作系统<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%B8%B8%E8%A7%81%E9%97%BB/" style="font-size:.88rem">日常见闻<sup>1</sup></a><a href="/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/" style="font-size:.88rem">时间管理<sup>1</sup></a><a href="/tags/%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/" style="font-size:.88rem">源代码管理<sup>1</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" style="font-size:.88rem">软件安装<sup>1</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" rel="external nofollow noreferrer" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8978256571" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C" title="建站经验">建站经验</a><a class="tag-list" href="/tags/Markdown" title="Markdown">Markdown</a><a class="tag-list" href="/tags/Java" title="Java">Java</a><a class="tag-list" href="/tags/SpringCloud" title="SpringCloud">SpringCloud</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://npm.elemecdn.com/instantsearch.js@latest/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js").then(t)};anzhiyu.addGlobalFn("themeChange",t,"mermaid"),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{"object"==typeof twikoo?setTimeout(o,0):getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(o)},o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.junpengzhou.top",region:"ap-shanghai",onCommentLoaded:()=>{anzhiyu.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.junpengzhou.top",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((o=>{t.textContent=o[0].count})).catch((t=>{console.error(t)}))})()};t()})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'><div class='name'><span>${e[n].nick} </span></div></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <time datetime="${e[n].date}">${anzhiyu.diffDate(e[n].date,!0)}</time></div>\n        </div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n&&(n.innerHTML=t),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.junpengzhou.top",region:"ap-shanghai",pageSize:6,includeReply:!0}).then((function(t){const n=t.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),10/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@latest/pjax.min.js"></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:type"]','meta[property="og:site_name"]','meta[property="og:description"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(anzhiyu.removeGlobalFnEvent("pjax"),anzhiyu.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script src="https://npm.elemecdn.com/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"https://npm.elemecdn.com/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1,scale:.5},react:{opacity:1},log:!1})</script></body></html>